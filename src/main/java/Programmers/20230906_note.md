### 9/6

무뱡향 그래프 간선의 표현

가중치 그래프 
-간선에 값이 있는 그래프 (이동 비용)

완전 그래프 
- 모든 정점이 서로 연결되어 있는 그래프 
- 정점이 N개일 경우, 간선의 수는 n(n-1)/2 개

완전그래프 같은경우 다 연결되어 있는 상황이다 
간선의 수는 n(n-1)/2 개이다

그래프 탐색 DFS
깊이 우선 탐색 (Depth First Search){
-각 노드에 방문했는지 여부를 체크할 배열과 스택 이용하여 구현

스택에다 각 노드를 어떻게 넣었는지 순서에 따라서 순서는 달라질 수 있다. 

A부터 순회를 한다고 하면 스택에 넣어줄 때 방문 배열을 트루로 한다. 
그리고 pop을 하고 
노드를 꺼내보고 꺼내봤을 때 
인접  정점을 체크해본다. 

D를 넣어주고 C를 넣어주고 B를 넣어준다. 
1로 다 체크를 해주고 
더 넣을게 없으면 스택에 체크를 해준다. 

A랑 E가 있는데 

F를 넣고 F를 1로 채워넣는다. 
BFS 라고 해서 너비 우선 탐색 
DFS 랑은 다르게 가까운 애들부터 순회가 되는 방법 
방문 여부 체크할 배열과 스택과 큐를 이용해서 구현 가능 

방문 배열은 똑같이 준비 해 두고 
큐를 하나 준비해준다. 
A를 큐에다가 하나 넣고 A가 먼저 출력되고 그다음 D가 먼저 출력이 되고 있고 
D를 넣어주고 C를 넣어주고 B를 넣어준다. 
큐 구조니깐 먼저들어왔던 D 가 나간다. 
A D D에 대해서 인접 정점들을 보면 F가 들어가고 

그래프의 구현 인접 행렬(Adjcency Matrix)
2차원 배열 이용

인접 행렬의 장단점 
-간선 정보의 확인과 업데이트가 빠름 O(1)
-인접 행렬을 위한 메모리 공간 차지

0 1 로 그래프가 어떻게 인접해있는지 체크 하기 

어떤 간선 정보를 확인하려하면 배열의 인덱싱으로 확인할 수 있다. 

두번째 방법은 연결리스트 이용

장점 메모리 사용량이 적고, 노드의 추가 삭제 빠름
단점 간선 정보 확인이 상대적으로 오래걸림

전체 정점 개수 x 전체 정점 개수 
N+E 
인접 행렬 인접 리스트 유리한 점 

인접 행렬을 이용한 그래프 구현 

각각의 알파벳을 담을 배열
이차원 배열
엘리멘트 카운트 

생성자 중에 size가 들어오면

인접 행렬도 n바이 n 만큼 만들어준다

public boolean isFull() {
return this.eleCn == this.vertices.length;

public void addVertex(char data) {
if (isFull()){

새로운 알파벳에 대한 정점을 확인할 때 isFull() 로 확인하고 

this.vertices[this.eleCnt++] = data;

public void addEdge(int x, int y ){
this. adj

a에서 b 로 가는 정보를 

방향 그래프라고 하면 한쪽만 업데이트 해주면 된다. 
public void addDirectedEdge (int x, int y) {
this.adjMat[x][y] = 1;

public void deleteEdge(int x, int y){

방향그래프였으면 지워지는 쪽도 작성 

인접 행렬을 출력하는 함수 작성
sout(" )
for(char item: ths.vertices) {

for()

인접 행렬을 이용해 만든 코드를 통해 풀어보자 
MyGraphMatrix graph = new MyGraphMatrix(e.length + 1);

for(int i = 0; i < e.length; i++){
간선 정보 추가한다. 

노드들에 대한 엣지 카운트

int[] edgeCnt = new int[e.length + 1];
for(int i = 0; i < graph.adjMat.length; i++){
for(int j = 0; j < graph.adjMat[i].length; j++){
if(graph.adjMat[i][j] == 1){
edgeCnt[i] += 1;

int maxCnt = -1;
int maxIdx = -1;

리턴할 떄는 맥스 인덱스 

비교했을 때 중복되는 값이 센터 노드인지확인

엣지 정보가 넘어오면 
0번째와 1의 0번째를 비교해보고 
0번째고 1의 1번째를 비교해본 다음에 
있으면 0번이 센터노드고 아니면  01 이 센터노드


비선형 자료구조 - 트라이

자료구조를 이해하고 삽입 삭제 탐색 구현 
Trie 

문자열을 저장하고 빠르게 탐색하기 위한 트리 형태의 자료구조
정렬된 트리 구조 
문자열 저장을 위한 메모리가 필요하지만 탐색이 빠름
길이가 N인 문자열 탐색의 시간 복잡도 O(N)

트리구조 
동일 위치에서의 공통된 부분을 

트라이에서 삽입(1)

처음에 apple을 삽입 
그다음에 april 이 들어오면 
그다음 r 이 필요할 때 
i 연결해주고 l 연결해주고 
끝노드라고 표시해준다. 
app 같은 새로운 문자열이 들어오면 
대신에 기존 흰색이였던 p를 얘로 끝나는 단어가 있다는 걸 표시해준다. 

다음으로 삭제해주면 

파란색 음영 처리로 apple 에 해당하는 모든 노드를 지우는게 아니라 필요한 부분 만 지워준다. 

이 상태에서 app을 지운다 하면 app을 찾아간다음에 
끝단어를 의미하는 p플래그를 없애준다. 

트라이는 key value, 로 이루어진 노드로 구성 
Key : 알파벳
Value : 자식 노드 

Hashmp을 이용한다. Character , Node 
    
Node root;

힙은 완전 이진 트리 형태이다
최소 힙, 최대 힙
-중복 값 허용
- 반 정렬 상태
- 최솟값 또는 최대값을 빠르게 찾아내는데 유용한 자료구조
- 

최소 힙
부모 노드의 키가 자식 노드의 키보다 작거나 같은 형태

최대 힙
그 반대 

부모 노드의 키가 자식 노드의 키보다 크거나 같은 형태

중복된 값들이 들어올 수 있다. 
최대 힙 같은 경우에는 완전 이진 트리 형태로 
좌측부터 데이터가 차져있다.

가장 위 루트 노드를 반환해서 삭제하면 된다. 

가장 마지막 위치의 노드를 최상위 노드로 위치 시킴
자식 노드 중 작은 값과 비교 후 부모 노드가 더 크면 자리 교체 (반복)






































