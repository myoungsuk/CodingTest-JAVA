### 10/09

코드를 통한 인프라 관리 
메타데이터 디스커버리 투 

aws 에서 서버리스 형태로 운영중 
단순히 aws 말고 데이터 센터도 가지고 있는데 데이터 센터와 aws 인프라를 서로
엮어서 사용하고 있다. 

aws에서 클릭클릭해서 만들었을 텐데 코드베이스로 관리하는걸 배울 예정이다. 

IaC라고 인프러 스트럭처 as Code 

수동 프로세스가 아닌 코드를 통해 인프라를 관리하고 프로비저닝 하는 것
어플리케이션도 하나의 코드로 관리가 된다. 
인프라 구성도 코드로 관리가 된다. 
요즘에 DevOps라 해서 인프라 관리를 하게 되는데

개발자 운영자 엔지니어 경계가 점점 허물어지고 있다. 
개발자도 인프라 관리를 할 줄 알아야된다. 

SaaS를 쓰려면 공식문서롤 보는게 낫다. 

실제로 접속을 해보면 VPC 생성을 하게 된다. 

VPC A와 B가 둘 다 접속 가능하도록 vpn 과 연결하거나 

데이터 센터랑도 연동을 하는 복잡한 구성을 해야하는 경우가 있다. 
콘솔 페이지 내에서만 작업하기에는 문제가 많다. 

복잡한 VPC를 해야되는 경우에는 A에서 만들때는 B에다ㅏㄱ 똑같은 구조를 하려면 
기억이 안나는 경우도 있다. 

보통 IaC 테라폼에 대한 예시를 들고 와 봤다. 

VPC를 생성하게 되면 코드 몇 줄로 인프라 생성이 가능하다. 

코드로 관리가 되면 하나의 값으로 관리가 되기 때문에 복사르 해서 쓰거나 참조해서 쓴다. 
인프라 설정에 대해선 IAC 관리해서 많이 하게 된다. 

동일한 환경을 반복적으로 생성하기 좋다. 

운영환경에다 똑같이 배포를 하기 떄문에 실수가 줄어들고 개발 운영 테스트 
스테이지 동일하게 배포 가능 

여러개의 환경
여러개의 계정을 쓰더라도 VPC 환경은 똑같은 경우가 있다. 

정책이라던가 보안 규정같은걸 줄 때 줄글로 쓰는것보다 테라폼에 있는 코드로 
전달해주는게 이해하기 좋을 수 있다 

협업도 가능하고 버전도 관리할 수 있다. 
실수 방지 

프레임 워크에 따라서 일부 코드로 관리가 되지 않는 영역 존재 
테라폼같은 경우에 aws 에 code series, event bridge 에 관리가 미비하다

Best Practice 에 대한 자료가 부족하다. 
다중 계정 운영 방식, 망분리(ISMS), 협업 등등

다중 계정을 어떻게 IaC를 통해서 협업할 수 있는가 에 대한게 부족하게 떄문에 
쓰기가 쉽지 않다. 

코드뿐만이 아니고 하나의 코드로 관리를 해야한다. 
인프라 환경을 변경 할 수 있기 때문에 DevOps vs Backend 개발자가 
권한이 거의 비슷해지는 상황이 온다. 

네트워크가 데이터같은경우 보안이 중요한데 
개인정보 처리 관련 

DevOps 개발자들은 그냥 peering 을 하기 때문에 문제가 생길 수 있다. 
Ec2이미지

우리 어플리케이션 코드에서 http 에서 https 로 리다이렉션이 필요하다. 
백엔드 개발자는  코드로 작성해서 테스트를 못해보니깐 권한 달라 한다. 

코드를 또 DevOps 개발자가 넘겨줘서 

콘솔이나 , AWSCLI 에만 알려주는데 테라폼에서 코드화를 하려면 테라폼에 있는 api 문서
만 보면서 코드화를 진행해야 된다. 

개발자가 직접 배포하고 인프라 환경도 구축할 수 있다. 
다 코드로 관리할 수 있다. 
장고 nodejs expressjs 설정 환경, 환경변수 이런걸 코드로 관리 할 수 있다. 

application 코드랑 인프라 코드랑 같이 할 수 있다. 
개발자가 생각 없이 서버를 늘려버린다던가 보안그룹을 조정해서 
anyopen 으로 열어버린다던가 할 수 있다. 

ReadOnly 권한을 주기엔 권한 설정을 할 수 없다 
권한이 두개밖에 없어서 개발자가 할 수 없느 ㄴ권한까지만 주 ㄹ수 있는데 
쉽지는 않다. 

오토스케일링 권한이 막혀서 안된다던가 
권한을 세부적으로관리하기가 쉽지 않다. 권한을 잘 못 줬을 때 문자가 발생하는게 
이런 부분이다. 

최대 서버 개수를 늘린다는건 바로 잡을 수 있는데 CloudWatch 같은 경우는 
점진적으로 증가하기 떄문에 발견하기 쉽지 않다. 

개발자에게 네트워크 권한을 줬더니 anyopen 한다더가 개인정보를 직접 본다던가 할 
수 있다. 
보안 위협도 발생할 수 있기 때문에 권한제어가 정말 어렵다. 

람다를 1분마다 실행해서 에러가 나는 걸 알림을 받는다거나 
콘솔에 들어가서 생성된 람다에 대해서 1분마다 실행하는거 만드는건 쉽다. 

요 콘솔에서의 작업을 테라폼 코드로 바꿔야된다하면 오른쪽 처럼 나오게 되는데 

요 템플릿을 문서로 제공해주지 않기 때문에 본인이 직접 찾아서 만들어야 된다. 

클라우드 워치 이벤트 룰, 콘솔에서는 arn 이란 갑이 없다

클라우드포메이션/SAM

CDK

테라폼 엔시블 
chef 랑 puppet 은 에이전트가 있어서 잘 안쓴다. 

서버리스 프레임워크 라는게 있다. 원하는 상태까지 단계가 

Go의 특징 적은 키워드 수, 컴파일 기반의 정적 타입, Duck Typing 지원, 다중
패러다임  GC, 빠른 컴파일 등을 지원 

현대판 C언어 같다. 
절차지향적이지만 동시에 모던한 OOP를 지원하고 함수형과 유사하게 작성할 수 있으며
포인터가 있고 C에서 없던 GC를 지원한다. 빠르게 컴파일 할 수 있고 고루틴 이라는
경량 쓰레드를 활용하여 동시/병렬 처리가 가능한 언어이다. 

암묵적 형 변환을 지원하지 않는다. 

JAVA의 primitive type 의 경우 작은 데이터 타입에서 큰 데이터 타입으로 변환시
암묵적 형 변환을 지원하지만 Go 에서는 명시적 형 변환ㅎ만 지원한다. 

Go는 강타입 언어라고 볼 수 있다

함수와 메서드가 구분되어 사용된다. 

함수와 메서드 차이는 객체로부터 독립 여부에 따라 달라지게 된다. 함수는 객체로부터 
독립적으로 작동하고, 메서드는 객체에 종속적이다. Java의 경우 함수를 
단독으로 선언할 수 없고 항상 클래스 구성안에 있어야 한다. 
따라서 함수라고 하지 않고 메서드라고 부르고 있다. 

Go의 경우 함수도 있고, 메서드도 있다. 

OOP를 지원하지만 클래스가 없다. 
클래스가 아닌 C 언어 계열의 "구조체(struct"를 확장하여 사용한다. 
메서드 예에서 Retangle 이라는 구조체를 선언했다. 

Java의 경우 메서드는 클래스 안에서 이루어지지만 Go 에서는 
receiver 라는 개념을 사용하여 구조체 밖에서 별도로 선언한다. 

OOP를 구조체의 확장형으로 사용하고 있기에 상속이 없다. 
Go에서는 구조체를 상속받는 구조체를 지원하지 않는다. 대신에 struct embedding 을 
사용하여 composition 방식을 언어 차원에서 지원하고 권장하고 있다. 

인터페이스르 지원한다. 

Duck typing 이란 

덕 타이핑 방식으로 작동하는 Go의 인터페이스이다. Go 에서 인터페이스의역할은
객체의 동작을 표현하는 것이고, 인터페이스가 표현한대로 동작하는 객체는 인터페이스를 
사용할 수 있다. 

type Duck interface {
quack() string
walk() string)

public private 접근제어자 대신에 대소문자로 구분한다. 

변수와 메서드 모두 대소문자로 구분된다. 
대문자 외부 패키지 접근 가능 
소문자 외부 패키지 접근 불가 

함수 / 메서드 리턴이 1 개 이상 가능하다. 

func main() {
a, b := vals()

exception이 없다. 

try-catch-finally 문을 사용하면 코드가 매우 복잡하고 처리하기 어렵다는 경향이 
있다고 한다. 

Multiple returns values 를 지워하여 Errors 를 동시에 반환하고, 
해당 함수/ 메서드를 사용하는 쪽에서 err에 대한 처리를 한다는 점 


func main() {
    f, err := os.Open("filename.ext")
    if err != nil {
        log.Fatal(err)
    }
    defer f.close()

고루틴 + 채널을 이용해 동시성을 처리한다. 

경량 스레드를 만들고 동시성 프로그래밍을 할 수 있다. 
race condition 문제를 방지하기 위해 mutext lock 이나 atomic을 만들 수 있지만 
보통 Go 에서 지원하는 채널을 사용하여 동시성 프로그래밍을 한다. 

pacakage main

import "fmt"

func main() {
    messages := make(chan string)
    
    go func() { message <- "ping"}()

    msg := <- messages
    fmt.Println(msg)

테스트, 벤치마크, 문서를 언어 차원에서 지원한다. 

godoc 생성을 언어 차원에서 지원한다. 
.go 파일이 xxx_test.go 이고 해당 파일의 내용중 함수명이
Testxxx(), 

와 같이 키워드를 붙여 사용할 수 있다. 

Go/Gin, Echo vs Java(Spring(Boot))

클라우드 포메이션이란 리소스 관리 시간을 줄이고 애플리케이션에 더 많은 시간을 사용하도록 해 주는 
서비스 
AWS 리소스를 설명하는 템플릿을 생성하면 해당 리소스의 프로비저닝과 구성을 담당함

aws 계정 내에 있는 리소스들을 만들어 준다. 

스택을 기반으로 생성된다.

템플릿 이라는건 yaml 이라 json 포맷으로 저장되는 파일이다. 

키 벨류로 저장되는데 

문법에 맞춰서 리소르를 만들면 된다. 

스택이라는 하나의 단위로리소스를 관리 
스택을 업데이트 함으로 변경이 된다. 

변경점들이 파악해서 클라우드 포메이션이 알아서 수행한다. 
클라우드 포메이션이 알아서 해줌

클라우드 포메이션에 대한 장단점 

IaC 공통적인 장점도 있지만 클라우드 포메이션 장점도 있다. 
인프라 관리 간소화 
aws 자체적으로도 관리가 된다. 

ec2 인스턴스를 생성하게 되며 ㄴ나중에 삭제하게 되면 ebs 라던가 백업 스냅샷은 알아서 
삭제가 안되는데
 cloudforamtion 은 자동으로 삭제해준다. 

실패를 했을 때 자체적으로 롤백을 지원해준다. 

aws에 대부분에 서비스에 대해서 모든 옵션을 제공한다. 

러닝커브가 어렵다. 
aws에 대해서 이해도가 엄청 높앋 배포에 필요한 모든 옵션을 직접 활용하기에는 설정이
너무많다. 

클라우드 포메이션의 단점 중 하나인데 
json, yaml 문법에서 값 찬조 방식이 난해하다. 

데이타를 표현하는 파일 포맷이라 특정 값을 참조한다 했을떄 추적이 어렵다. 

변수명을 많이 선언해서 쓰면 
키 벨류 형태로 선언할 수 있다. 
apiKeySourceType 이라는걸 참조하기 위해서는 밸류쪽에다가 !Ref해서 키값을 찾아줘야된다. 

apiKeySourceType 중복되는 값이 벨류에 들어있다 했을 때 잘못바꾸면 큰일생김

다행이 yaml 같은 경우에는 코드 길이가 짧아서 보기 편한편

Json 같은 경우는 똑같은 코드인데 코드가 괄호 하나차이때매 너무 큼


Serverless Application Model SAM 
오픈소스 프레임워크 
코드 기여를 할 수 있다. 

서버리스 애플리케이션 구축을 위한 오픈소스 프레임워크기 때문에 대부분 

AWS CLI SAM CLI 깔았던 이유가 CLoudFormation 을 수행할 수 있다. 

SAM을 간단하게 설명을 들어봤으니깐 예시를 보도록 하자 
SAM CLI 를 보게 되면 
최초의 프로젝트 설정 빌드 배포 명령어 한줄로 가능

db api 등등 
api gateway를 배포하게 되는 공식 
리소스로 람다 functionOVerHttps 
타입은 서버리스 function 
api 에 람다를 붙여서 쓰겠다. 

다이나모 디비를 접근
api 경로는 이렇게 할 것이다. 

람다가 하나가 추가되면 밑에 더 생길 것 

다이나모 db 생성하는 리소스도 추가할 수 있을 것 
뒤에서 간단하게 API GateWay를 생성해보는 실습 해보자 

CLI와 템플릿에 대해 간단한 예제를 봤다. 

CloudFormation/SAM 

클라우드 포메이션은 하나하나 체크해봐야한다

템플릿 말고 이름 모를 파일 

템플릿을 통한 상태값들 현재 매핑되어있는 값들을 지정해놓는것 









































