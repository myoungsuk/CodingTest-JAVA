### 9/24

밴더에서 기본적으로 제공하는 내장 함수 
DBMS 내장 함수 

일단 대부분의 데이터베이스에서 제공되는 함수

문자를 어떻게 처리할지에 대한 부분 
문자를 숫자로 변환할 수도 있고 
숫자로 처리하는 함수는 숫자를 입력하면 숫자 값을 반환

날짜 연산이 많이 사용되고 있음

문자형 함수, 숫자형 함수, 날짜형함수 변환형 함수, NULL관련 함수 

숫자의 올림, 버림, 반올림하고자 할 때 

특정 날짜에 년수, 월수, 일수를 더하거나 빼고자 할 때

두 날짜 사이의 년수, 월수, 일수 , 시간의 차이를 알고자 할 때
문자열 -> format에 맞게 날짜로 변환

switch문 == case 문 

case when 조건 1 then 결과
else 그외 값

length(password) as password_length 를 통해서 알 수 있다. 

case
    when length(password) > 2 then concat(substring(password, 1, 2), '**)
    else ''
end as password_mask
from member;

password_maks라는 내용이 이렇게 나오게 된다.

concat을 이용해서 문자열을 합치고 
특정한 길이만큼 문자열을 가져오고 

이렇게 문자열처리하는 함수에 대해서 알아봤고 

데이터 표시 포맷(날짜 -> 문자열, 문자열 -> 날짜)

날짜라는 부분이 굉장히 많은 조회에 발생하기 떄문에 

select register_data
    , date_format(register_date, '%Y.%m.%d') as dt_format
from member_detail;

문자열에 대해서 조건을 가지고 처리할 때 많이 쓴다.

select '20220321'
    ,str_to_date('20220323', '%Y%m%d') as dt_date
from dual;

2022-03-20 06:25:20 -> 2022-03-01

select now()
    , date_format(now(), '%Y-%m-01;) as start_date
from dual;

마지막 날짜는 어떻게 구하면 될까요?

01은 명확하게 구할 수 있으니 그 날짜에서 하루를 빼는 식을 짜면 된다.

date_format(now(), '%Y-%m-01'), %Y-%m-%d')

interval 1 month)


페이징 처리에 대해서 알아보자 
데이터는 엄청 많음
한꺼번에 모두 볼수 없기 때문에 
특정 위치부터 특정 개수까지 내려줌
MySQL, MariaDB의 경우 limit을 이용하여 페이징 처리 가능
Oracle의 경우 ROWNUM을 이용해서 페이징 처리 가능
MSSQL의 경우 OFFSET, FETCH를 이용해서 처리 (2012) 이후 

select * 
from actor
limit 0, 10
;

limit을 이용해 10개의 데이터를 볼 수 있고 
다음데이터를 보고싶으면 10, 10


select *
from
(
select c.code, c.company
)

리미트를 이용하거나 서브쿼리를 이용해서 조건 처리 가능 
selectfrom(
selectfrom
select a.*
)

view 테이블 
- 실질적으로 존재하는 테이블이 아니라 정의만 가지고 있음 
- 가장 read only 테이블
- 사용에 있어서, 테이블과 동일 (단, select에 대해서만)

장점
독립성
편리성
보안성

create view 뷰테이블 명 as
    쿼리 작성
;

drov view

앨리어스라는 걸 해서 별칭을 주어지고 쉽게 접근하도록 했는데
마찬가지로 뷰도 테이블에 대해서 간단하게 한다던지 할 수 있다. 
보안적인 측면에서 테이블을 password 같은 경우 보여주고 싶지 않아서 
view 에 대해서 패스워드에 대한 정보만 빼고 보여줄 수 있도록 한다. 

뷰를 쓰지 않는 곳은 안쓰기도 한다. 

뷰 역시 크리에트와 

select *
from member;

select *
from member_detail

멤버는 m 하구요
join member_detail md on md.member_type = m.member_type and md.user_id = m.user_id

m.member_type, m.user_id, m.password, m.name
md에 대해서는 mobile_no, md.marketing_yn, md.register_date

멤버타입과 유저아이디는 중복되니깐 굳이 보여줄 필요 없다. 

이걸 뷰로 만들어보겠다. 

create view v_일반적으로 이런식으로 표시한다. 

v_member as 해서 

select *
from v_member
;

join 쿼리는 복잡하지 않지만 두개의 커리 관련해서 하나로 만들면 쉽게 할 수 있고 
패스워드에 대해서는 보여주고싶지않은 권한이 있다 했을때 

drop view v_member;

패스워드를 만들지 않고 view를 만들 수 있다. 

패스워드가 보여지지 않는 테이블을 만들 수 있다. 
다른 멤버들에게 공개할 때 공개하고싶은 정보만 보여줄때 이용할 수 있고 
보안적인 측면

쿼리 자체가 지금은 join 자체가 복잡해보이지 않지만 복잡한 쿼리를 심플하게 
만들어 쓸 수 있는 방법이기도 하다. 

select member_type
    ,user_id
    ,name
    ,mobile_no
    ,marketing_yn
    ,register_date
from v_member
where 

where 마케팅 yn 이 트루인걸로 하겠다. 

뷰 멤버에 마케팅 yes인 뷰로 만들겠다. 
하면 

select * 
from v_member_marketing_yes
결과는 

마케팅 yn 이 yes 인 형태의 조건의 데이터만 보여줄 수 있다. 
view 에서도 조건을 추가적으로 줄 수 있다. 

drow view 하고 
v_member_marketing_yes;

뷰 멤버를 만들엇다. 그리고 이걸 가지고 조작을 할 텐데 
구조가 멤버에 대한 구조가 바뀌면 
뷰를 새롭게 수정해줘야되는 이슈가 있다. 
그래서 적절하게 쓰면 굉장히 좋다. 

함수에 대해서 말해보자
dbms에서 제공되는 공통적 함수 의외에 사용자가 직접 정의하고 작성 
sql을 활용하여 일련의 로직을 수행하고, 수행 결과를 단일 값으로 반환할 수 있는 모듈

함수는 어떤 특정한 단일값을 리턴하는걸 얘기한다. 

하나의 값을 리턴하기위한 함수라고 한다. 
delimiter $$

문자열을 리턴하는 function을 만들어보자 

create function sf_password(password varchar(255))
    returns varchar(255) 를 통해서 리턴한다고 정할 수 있다. 
실제적으로 로직을 작성하자

begin이라는 구문과 

end 라는 구문 사이에 로직을 작성하면 되는데

return '*****'를 구성하는 function을 만들며 
routine 이라는 카테고리 안에 생긴다. 
어떻게 실행하냐면

select length('abc);

select sf_password('1234');
를 실행할 수 있다 .

오라클 같은 경우는 
select sf_password('1234')
from dual; 을 통해 호출 할 수 있다. 

drop function sf_password;

회원정보를 보면 
select *
from member;

패스워드를 마스킹하는 function을 만들 수 있다. 

password가 이렇게 있으면 
password를 그때 어떻게 하냐면 
문자열을 통해서 
case 
    when length(password) > 0 then substr(password, 1, 1)
concat을 이용해서 별표로 붙였다. 
아닐때 else'****' 만 했다. 

이런 부분들이 select 내에 있으면 복잡하니깐 function으로 빼보도록 하자 

password 넘어온 파라미터 가지고 마스킹 처리를 하는 것

create function sf_password(password varchar(255))
    returns varchar(255)
begin 
    return
    case
        when length(password) > 2 then concat(substring(password, 1, 2, '**')
        else
            '****'

end;

select password라고 해서 그대로 값을 가져올 수 있다.
select password, sf_password(password) as password_mask
from member;

데이터를 function을 이용해서 

select password, sf_password(password) as password_mask
from member;

매 사람마다 그걸 만들어 쓰는것보다 function을 다같이 쓰는게 좋을 것










































