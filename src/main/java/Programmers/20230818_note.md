### 8/18

latch를 8개를 연결하면 되는 것
인풋으로 각각의 자리수에 들어가 되고 8비트 latch 라고 부른다. 
우리가 쓸만한 메모리가 나오기 시작함

8비트가 들어가 있는데
S0, S1, S2가 셀렉터에서 쓰이는 인풋 3개
NOT 게이트 같은경우에는 저렇게 연결되어있고

인풋 스위치를 가지고 여덟개의 유니크한 신호를 보낼 수 있는 것
AND 게이트를 하면 다 해야 1이 되는거니깐
8개의 데이타 인풋에 이런식으로 연결을 하면 앞부분에 AND 게이트를 놓으면
특정 비트만을 선택할 수 있고 
OR 게이트로 연결해 놓으면 특정 비트가 1 이면 output을 할 수 있다

8개에 대해서 하나만 선택할때
인풋 3개정도 필요하다. 
이런 식으로해서 8개 일종의 공간이라고 해서 
일종의 주소를 선택하는 것

어떤 데이터를 넣는다면 그 주소 공간에 이 데이터를 딱 넣는 것 
이러한 기능을 3-8-decoder 를 사용해서 지원이 가능하다. 

3-to-8 decoder와 8-to-1 decoder 를 하면 
세 개의 입력 부분도 저렇게 연결되어 있으니깐 데이터 인풋이 있으면 데이터가 들어갈 것이고 
이 latch 에 있는 값을 선택하게 될 것이고 아웃풋으로 출력할 수 있게 된다. 

이게 바로 주소, Address임
S0, S1, S2 가 decoder와 selector에 동일하게 적용(데이터 읽고 쓸 수 있는 Address)
write가 1 이면, Address 에 Data in 값이 씌여짐
Data Out은 항상 Address에 해당하는 값을 출력한다. 

RAM
8 x 1 RAM : 8비트 중 1개의 특정 비트를 쓰고 읽을 수 있는 메모리
특징 데티ㅓ를 저장할 수 있음
read/wirte : 특정 공간에 새로운 데이터 저장 읽기 가능
randomAcecess : address 지정을 통해 특정 공간 값 적용 가능 

여러가지의 비트를 
8 x 2 개를 저장하고 
16 x 2 라고 생각할 수 있는데
주소가 동시에 항상 가리키고 있기 때문에
두개의 데이터를 한번에 쓰고 읽을 수 있게 되는 것이다. 

팔곱하기 이는 2 비트 데이터 단위로 읽고 쓸 수 있게 되는 것
요 팔곱하기 2 램에 1-to-2 Decoder 하나의 데이터는 입력이 들어가는데 
이중에 하나 D0, D0 
어드레스 플러스 세개 셀렉까지하면 4개의 16개가 필요한것 
네번째 주소 역할을 한 것이 
2-to-1 selector 라 하면 
여덟개중에 하나가 저장이 될 것이고 
아웃풋이 하나 나올건데 어차피 동일하니까 저 주소를 선택해서 
데이터가 출력하게 될 것이다. 

2의 4승 16개르 ㄹ각각 선택할 수 있고 
latch 데이터를 저장할 수 있고 읽을 수 있는 샘이 되는 것

m * n RAM array  많은 데이터를 저장하는 RAM array 만들기
여러 개의 Select로 / Decoder/Selector 를 구성하면 
ram array를 만들게 된다. 
2의 10승이면 1024를 만들게 되고 
1024 * 8 bit 
이런식의 메모리를 만들 수 있다. 

킬로바이트와 킬로비트의 차이
1024키로바이트는 1mb 
1024 mb 는 1g

비트 단위로 킬로 비트를 쓸 때가 있는데 네트워크에서 많이 사용되는 언어이다. 

2의 16승 
65536인데 하나에 1 비트씩 
64k 램이 s 전자에서 세계 최초로 만들면서 상용화가 되면서 
우리나라 반도체가 상용화 되기 시작했다. 

메모리의 공간은 다 이런식으로 주소가 있다. 
주소가 2진수로 되어있기 때문에 
사람이 확인하기엔 불편한 감이 있다. 
그래서 변수명을 사용하는 것

가산기란 덧셈을 하는 기계라고 보면 된다. 
덧셈을 하는 전가산기를 봤는데 덧셈을 어떻게 하는지에 대해 초점이 맞춰젔다 하면
그 로직을 가지고 실제로 컴퓨터에서 어떻게 계산이 되는지 확인

clear or 게이트 이기 때문에 

Adder가 동작을 해야되는데 A라는 값을 받고 B라는 값을 받는데 
A더하기 0은 A가 된다. 
저장을 해야되는데 Add 버튼이 눌리면 write처럼 그 때 비로소 A가 저장이 되고 
출력으로 
A+B에 대한 결과값을 우리가 확인할 수 있다. 
A+B가 계속 들어가고 있다. clear를 눌러주면 출력에 있는 모든 값은 0이 된다. 
A+B를 한번에 넣어주는게 아니라 A먼저 넣고 B 넣어서 축적되는 느낌이라 Accumulator 라고 
할 수 있다. 
그리고 clear라는 추가적인 스위치가 필요하다. 
이 Accumulator 가 CPU 안에 들어가 있다. 
임시적인 공간이 필요하다. 그래서 CPU 안에는 여러가지 데이터 처리를 위한 공간이 있다. 
그걸 레지스터라고 부른다. 

딱 하나의 데이터를 저장하는 레지스터가 여러개가 있는 경우가 많다. 
CPU 안에 다른 CPU 회로와 데이터를 가져온다든가 쓴다는게 
운영체제 더 나가아서 프로그램에 언급이 될 수 있는 저장체제이기 떄문에 
중요하다. 

요즘 CPU는 레지스터 의외에도 캐시를 저장하느 ㄴ다른 공간이 있다. 
메모리를 접근했다가 갔다오는데 200cycle 정도가 걸린다고 할 수 있다. 
메모리에 있는 데이터를 갖고 오는게 폰 노이만 구조이다. 
메모리에 있는 동일한 주소
캐쉬에 있는지 단기별로확인
캐쉬는 메모리보다 ㄴ작다 
아주작은 공간이지만 시피유 바로옆이라 바로 가져옴

SSD 나 하드디스크는 단위가 다르다. 
이 사이클의 범위를 넘어서서 단위가 다를정도로 다른걸 가져오는건 굉장히 많은 시간이 
걸린다. 
최대한 메모리 안에서 처리를 해야된다. 
레지스터도 가산기를 기반으로 만들어진다. 

CPU에 가장 가까운 기계어 
실제 덧샘이 어큐뮬레이터를 이용하기 떄문에 시피유에서도 여러가지 레지스터가 필요했다. 

실질적으로 cpu 안에서 계산이 되는지 알아봤다. 
예전에 클럭이라는 기능을 하는 부품을 이해해봤는데
PC라는걸 알아보자
Program Counter (PC) 1씩 증가하는 레지스터 PC라고 하는 레지스터에 쓰여진다. 
클럭이 일어나면 1씩 증가한다고 볼 수 있다. 

5로 바껴졌다. 
주소를 넣는 부분에 PC값을 가져와서 주소에 대입하는 부분
또다른 복잡한 논리회로가 있다. Control panel 이라고 하자 
cpu가 조금더 프로그래밍스럽게 동작하는지 이해해보자

각 숫자를 0000h 부터 순차적으로 써넣는다. 
이런 기능을 하는 부품이라고 생각해보자
Takeover 스위치를 1로 한 후 각 숫자를 각 주소에 써넣는다. 
takeOver를 0으로 해서 ram을 제어하지 않도록 하자
clear

0000h 에는 1이 쓰여있고 
0001h 에는 2 가 쓰여있고 
1이 들어갈 거고 
1+2가 될것 그럼 3을 결과물로 확인할 수 있다. 
클럭이 계속 피시에 들어가고 
PC카운터는 하나씩 증가가 될 것이고 전체적으로 clear 스위치가 있어서 
최종 계산된 결과값이 초기화 시켜서 다시 0번 주소부터 넘어간 대로 할 것

핵심은 회로르 ㄹ바꿀 필요가 없다. 
어떤 메모리를 그냥 구성만 하면 된다. 

코드는 위에서 밑으로 순차적으로 실행이 된다. 
이코드를 메모리에 넣고 
pc 주소를 넣어주면
순차적으로 하나씩 실행이 되

Automation이라고 해서 일종의 프로그래밍

세 수를ㄹ 더하고 두수를 더하고 세 수를 더한다고 가정

이런 데이터를 긁어서 accumulator에 넣는 과정과 이런 accumulator를 하는 것만큼
구성하면 되고 특정 주소에 데이터를 저장하면 되고 
회로없이 명령만 잘 짜주면 cpu 가 맞춰서 동작을 하지 않을까

어셈블리어를 보면
load add store
명령은 어떻게 가져올 것이냐
메모리 공간을 분리하는 것
분리해서 동일한 주소로 명령을 갖고있는 메모리 / 데이터 주소값을 가지고 있느 ㄴ메모리에
동일하게 대입하면
0000h 

그래서 데이터와 코드를 램으로 분리해서 하면 기재가 가능하다
Load, Add, Store 
각각의 기능에 동작하는 회로가 CPU에서는 각각의 명령들이 어떤 의미를 가지는지 번호를 붙여놓음
10h 라고 하면 load 라는 명령이구나

명령 set이 존재한다 
각각의 명령마다 대응하는 일종의 코드가 있다. 
그래서 map 같은 경우에는 ARM 이라는 CPU를 쓴 
인스트럭션 셋 Operation Code opcode 라고 하낟. 
각각 다 다르기 때문에 intel cpu에 맞게 기계어로 변환하는 것과 ARM 과 전혀 다른 
코드를 가지고 있기 때문에 intel 용 arm 용 프로그램이 따로 있는 것이다. 
Load
Store 

이런 식으로 회로를 추가해 가면서 명령들을 추가할 수 있느 ㄴ것이고 
opcode를 기반으로 해서 어셈블리어로 기계어로 원하는 동작을 할 수 있도록 프로그래밍을
할 수 있지만 너무 복잡하기 때문에 우리가 고급언어를 쓰는 것이다. 





































