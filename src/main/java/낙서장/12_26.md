### 12 26

KQL 문법
필드명 *
필드명:값
필드명:값 AND 필드명:값
필드명:값 OR 필드명:값

특정 필드의 값이 일치하는지 
필드명:값

clientip : 172.155.

앞에 있는 헬로 월드는 토큰이 쪼개지면서 
뒤에있느 따음표있는 헬로 월드는 정확하게 따짐

묶지 않았다면 coming up 도 찾겠지만 아닌것도 찾고 있다. 
따옴표가 묶인것과 아닌걸 찾고 있다. 

로그에 bytes라는 필터가 있다. 
특정 타입의 값은 범위를 이용해서 필터링 가능 
bytes : [1000 TO 2000]

정규화시 고려해야하느것
얼마나 빠르게 데이터의 최신성을 보장해야하나
객체의 탐색 깊이가 얼마나 깊은가?
A->B->C->D->E->F->G->H->I->J->K->L->M->N->O->P->Q->R->S->T->U->V->W->X->Y->Z
객체의 탐색 깊이가 깊다면 정규화를 하지 않는것이 좋다.
객체의 탐색 깊이가 얕다면 정규화를 해도 된다.

C의 D참조가 변경될 경우 
B의 D 참조도 같이 변경되어야 한다. 

읽기 성능을 위해서 쓰기 성능을 희생한 것

정규활르 하기로 했다면 읽기시 데이터를 어떻게 가져올 것인가 
테이블 조인을 활용하는데 사실 고민해볼 문제다. 
테이블 조인은 서로 다른 테이블의 결합도를 엄청나게 높인다 
조회시에는 성능이 좋은 별도 데이터베이스나 캐싱등 다양한 최적화 기법을 이용할 수 있다. 
조인을 사용하게 되면, 이른 기법들을 사용하는데 제한이 있거나 더 많은 리소스가 들 수 있다. 
읽기 쿼리 한번더 발생하는 것은 큰 부담이 아닐 수도 있다. 














































