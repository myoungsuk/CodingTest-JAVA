### 11_24

유저 히스토리에도 리스너를 추가적으로 붙여보자 
@EntityListeners(value = MyEntityListener.class) 를 붙여준다.

인서트와 업데이트한게 동시제 저장된다. 

유저인서트를 하기전에 유저 히스토리를 저장하나. 
업데이트를 하기전에 유저 히스토리를 저장한다. 

유저 히스토리는 2개가 쌓이게 되고 

implements Auditable 을 해주면
@CreatedDate
@LastModifiedDate
@CreatedBy
@LastModifiedBy
를 사용할 수 있다.

데이터의 변경을 추적하기 위한 날짜 변경 방법을 처리하는 방법을 배웠다. 

다양한 방식으로 엔티티 리스너를 적용해볼수있다. 
유저 히스토리에 다른 엔티티를 만들었을 때 간단한 방식으로 참조만 하는것으로 리스너를 
사용하는걸로 할 수 있다. 

생성일 수정일 그런정보들은 원체 많이 사용되는 정보이다. 그래서 스프링에서는 
별도의 기본 메서드를 제공하고 있다. 

EnableJPAAuditing 을 사용하면 된다.

MyEntityListener 를 제거하고
@EnableJpaAuditing 을 붙여주면 된다.

AuditingEntityListener.class 를 사용하면 된다.
유저 히스토리도 AuditingEntityListener.class 를 사용하면 된다.
Auditing으로 지정해야 할 데이터에 @CreatedDate어노테이션을 달아준다. 

update에는 @LastModifiedDate 를 달아준다.
자동으로 값을 처리해주게 된다. 

여기선 createdat과 updateAt이 적용되지 ㅇ낳았다. 

@CreatedDate
@LastModifiedDate
어노테이션을 적용해주고 진행하면
유저 히스토리에 간단하게 추가할 수 있다. 

Auditing 감시라는 표현에 맞게 AuditingEntityListener.class 를 사용하면 된다.
Auditing은 몇가지를 제공하는데 
createdby LastModifiedBy 등등이 있다.
생성 또는 수정한 사람의 정보를 함께 저장할 수 있는 기능이 있다. 
스프링 시큐리티를 사용해서 인증정보를 가져오게 되면 좀 더 편리하게 사용할 수 있다.

실제로는 결국 createdAt과 updatedAt이 어노테이션을 적용시켜줘야되는데 
모델에다 추가해주면 된다. 

결국 반복되는 코드가 나오기 때문에 
BaseEntity 클래스를 만들어주고 
LocalDateTime createdAt;
LocalDateTime updatedAt;
를 추가해준다.

@CreatedDate
@LastModifiedDate

@EntityListenrers(value = AuditingEntityListener.class) 를 추가해준다.
Auditing을 이렇게 해주고 

CreatedAt과 UpdatedAt은 게터 세터가 필요하기 때문에 
MappedSuperclass 를 추가해준다.
이 어노테이션은 해당 클래스의 필드를 상속받는 엔티티로 포함시켜준다느 ㄴ뜻이다. 
무슨뜻이냐며 ㄴ유저의 extends BaseEntity를 해주면
유저 히스토리에도 createdAt과 updatedAt이 추가되는것이다.

extedns baseEntity implements Auditable

엔티티 리스너를 제거해줘도 된다. 

UserHistory extends BaseEntity
이렇게 하고 테스트를 실행시켜보면 
유저 히스토리에 대한 변경이 되는걸 확인 해 볼 수 있다. 

상속받은 클래스에 대한 정보 처리가 되지 않는다. 
라는 워닝이 나오고 
두가지 어노테이션에 대한 정보를 재정의 해준다. 
@ToString(callSuper = true)
@EqalsAndHashCode(callSuper = true)

@ToString(callSuper = true)
@EqalsAndHashCode(callSuper = true)

상속받는 클래스까지 투스트링 하고 이퀄스 해시코드 하겠다는 말이다. 
이렇게 하면 정상적으로 tostring이 출력이 된다. 

baseEntity에 정상적으로 들어간걸 확인할 수 있고 

반복적으로 CreatedAt과 UpdatedAt을 사용할 수 있다.
이벤트 엔티티리스너를 달지 않아도 해당 이벤트를 진행 할 때마다 
생성 수정이 되서 저장이 된다. 

해당 클래스를 상속받는 방식으로 개발하고 진행읻 ㄴ된다. 

우리는 db를 사용함에 따라 자연스럽게 relation에 대해서 생각해보게 된다. 

동명이인같은경우 relation을 사용하게 된다.
해당 유저가 연관성이 있다는 정보만 가지게 되는 것이다. 
martin이 tee
















































