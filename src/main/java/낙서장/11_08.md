### 11_08

ioc라는건 스프링에서 관리하기떄문에 스프링으로 시작해준다. 
스프링이 관리해주는 객체를 빈이라고한다.
빈을 관리해주는것이 ioc컨테이너이다.
빈을 관리해주는 ioc컨테이너는 두가지가있다.
1. BeanFactory
2. ApplicationContext

BeanFactory는 빈을 관리해주는 가장 기본적인 컨테이너이다.
ApplicationContext는 BeanFactory를 상속받아서 만들어진 컨테이너이다.
ApplicationContext는 BeanFactory보다 더 많은 기능을 제공한다.
그래서 BeanFactory보다는 ApplicationContext를 더 많이 사용한다.

스프링의 ioc는 스프링 컨테이너가 생성부대에서 다 가져간다. 

객체로 관리해야되는데
객체로 관리하게 만드는 어노테이션에 있다. 
@Component
빈으로 등록된다고 표시가 된다. 
스프링부트어플리케이션이라는 어노테이션은 본인이 가지고있는 자바 객체들이 나와있다. 

ioc어플리케이션이라는 것도 있다. 
ioc어플리케이션이라는것도 빈으로 등록이 된다는 것이고 
@Component

base

컴포넌트로 등록하면 
url 인코더도 빈으로 등록이된다고 한다. 

스프링컨테이너에 접근을 해 객체를 가져오기위해선 접근을 하기위한 코드가 필요한데 
applicationContextProvider implements ApplicationContextAware

얘도 스프링에서 컴포넌트로 관리를 해줘 
ApplicationContext context;

주입이 일어나면
context = applicationContext;를 할당하게 한다. 

public static getContext() {
return context;
}

ApplicationCntext context = ApplicationContextProvider.getContext();

Encoder encoder
di는 해줄거니깐 ioc는 new로 안할거다

Base64Encoder base64Encoder = context.getBean(Base64Encoder.class);
Encoder encoder = new Encoder(base64Encoder);

UrlEncoder urlEncoder = context.getBean(UrlEncoder.class);
찾아와서 
set메소드 하나 만들자 

public void setIEncoder(IEncoder iEncoder) {
this.iEncoder = iEncoder;
}

Encoder encoder = new Encoder(base64Encoder);

encoder.setIEncoder(urlEncoder);
result = encoder.encode(url);
sout    result

스프링한테 권한을 넘겼고 어플리케이션이 bean을 관리하기 때문에 ioc라고 하는것
인코더도 컴포넌트 붙여주면 된다. 

두가지 타입이 있는데
bean은 하나만 있으면 거기 맞춰준다. 
근데 url이랑 base도 컴포넌트면 스프링에서 어떤걸 매칭해줄지 결정해주지 못한다. 
그래서 
@Qualifier("urlEncoder") 라고 지정을 해주면 된다. 

자바의 메모리 공간은 크기 Method 영역, Stack영역 Heap 영역으로 구분되고, 데이터 타입
에따라 할당된다.

Method 영역: 전역번수와 static 변수를 저장하며, Method영역은 프로그램의 
시작부터 종료까지 메모리에 남아있다.

스택영역 : 지역변수와 매개변수 데이터값이 저장되는 공간이며, 메소드가 호출될때
메모리에 할당되고 종료되면 메모리가 해제된다. LIFO 구조를 갖고 변수에 새로운
데이터가 할당되면 이전 데이터는 지워진다. 

힙영역 : new키워드로 생성되는 객체, 배열등이 heap 영역에 저장되며, 가비지 컬렉
션에 의해 메모리가 관리되어 진다.

각 메모리 영역이 할당되는 시점은 언제인가요?

Method 영역: JVM이 동작해서 클래스가 로딩될 때 생성
Stack 영역 : 컴파일 타임 시 할당
Heap 영역 : 런타임시 할당

컴파일 타임 : 소스코드가 기계어로 변환되어 실행가능한 프로그램이 되는 과정
런타임 : 컴파일 타임 이후 프로그램이 실행되는 때

클래스와 객체에 대해 설명해주세요 
클래스는 객체를 만들어내는 설계도 혹은 틀이라고 할 수 있고 객체를 생성하는데 사용한다.
객체는 설계도를 기반으로 생성되며, 자신의 고유 이름과 상태, 행동을 갖는다. 
여기서 상태는 필드, 행동은 메소드라고 한다. 
객체에 메모리가 할당되어 실제로 활용되는 실체는 인스턴스 라고 부른다. 

생성자에 대해 설명해주세요
생성자는 클래스와 같은 이름의 메소드로, 객체가 생성될때 호출되는 메소드이다. 
명시적으로 생성자를 만들지 않아도 default로 만들어지며, 생성자는 파라미터를 다르게
하여 오버로딩할 수 있다. 

Wrapper Class란 무엇이며, Boxing과 UnBoxingㅇㄴ 무엇인지 설명해주세요
기본 자료형에 대한 객체 표현을 Wrapper class 라고 한다. 
기본 자료형 -> Wrapper class로 변환하는 것을 Boxing 이라 하며, 
Wrapper class -> 기본 자료형으로 변환하는 것을 UnBoxing이라 한다. 

래퍼 클래스란(Warpper Class) 기본 자료형에 대한 객체 표현을 Wrapper class라고 한다.
크게 기본 타입과 침조 타입으로 나누어진다. 

대표적으로 기본 타입은 char, int, float, double, boolean 등이 있고, 
참조 타입은 class, interface 등이 있는데 
프로그래밍을 하다보면 기본 타입의 데이터를 객체로 표현해야하는 경우가 종종 있다. 

이럴 때 자료타입을 객체로 다루기 위해서 사용하는 클래스들을 래퍼 클래스라고 한다. 
자바는 모든 기본타입 값을 갖는 객체를 생성할 수 있다. 

이런 객체를 포장 객체라고 하는데 그 이유는 기본 타입의 값을 내부에 두고 포장하기 때문
이다. 

래퍼 클래스로 감싸고 있는 기본 타입 값은 외부에서 변경할 수 없다. 만약 값을
변경하고 싶다면 새로운 포장 객체를 만들어야한다. 


int 
primitivie 자료형 
산술연산 가능
null로 초기화 할 수 없다. 

Integer
Wrapper class
Unboxing을 하지 않으면 산술 연산이 불가능하지만 null 값을 처리할 수 있다. 
null값 처리가 용이하기 떄문에 SQL과 연동할 경우 처리가 용이함
DB에서 자료형이 정수형이지만 null 값이 필요한 경우 Integer사용

Synchronized에 대해 아는대로 말해주세요

여러개의 쓰레드가 한 개의 자원을 사용하고자 할 때, 현재 데이터를 사용하고 있는 
쓰레드를 제외하고 나머지 쓰레드들은 데이터에 접근할 수 없게 막는 개념입니다.

데이터의 thread-safe를 하기 위해 자바에서 싱크로나이즈드 키워드를 제공해 멀티
쓰레드 환경에서 쓰레드간 동기화를 시켜 데이터의 thread-safe 를 보장한다. 

synchronized 키워드는 메소드나 블록에 사용할 수 있으며,
synchronized 키워드가 붙은 메소드나 블록은 한 번에 한 쓰레드만 실행할 수 있다.

new String() 과 리터럴의 차이에 대해 설명해주세요
new String()dms new 키워드로 새로운 객체를 생성하기 때문에 Heap 메모리영역에
저장되고 리터럴은 Heap안에 있는 String Constant Pool에 저장된다.


String, StringBuffer, StringBuilder의 차이를 설명해주세요
String은 불변의 속성을 가지고, StringBuffer와 StringBuilder는 가변의 속성
을가진다. 

StringBuffer는 동기화를 지원하며, 멀티 쓰레드 환경에서 주로 사용하며, 
StringBuilder는 동기화를 지원하지 않아 싱글 쓰레드 환경에서 주로 사용한다. 

String 객체가 불변인 이유는?
1. 캐싱 기능에 의한 메모리 절약과 속도 향상
자바에서 STring 객체들은 Heap의 String Pool이라는 공간에 저장되는데, 참조하려는 문자열이
String Pool에 존재하는 경우 새로 생성하지 않고 Pool에 있는 객체를 사용하기 때문에 특정 문자열 값을
2. 재사용하는 빈도가 높을 수록 상당한 성능 향상을 기대할 수 있다. 

Thread -safe
-String 객체는 불변이기 때문에 여러 쓰레드에서 동시에 특정 String 객체를 참조하더라도 안전하다. 

보안기능 
-중요한 데이터를 문자열로 다루는 경우 강제로 해당 참조에 대한 문자열값을 바꾸는게 불가능해 보안에 유리함

접근 제한자(Acess Modifier) 에 대해 설명해주세요
변수 또는 메소드의 접근 범위를 설정해주기 위해서 사용하는 Java의 예약어를 의미하며, 
총 4 가지 종류가 있다. 
public 접근 제한 없음 프로젝트 내 어디서든 사용 가능
protected 해당 패키지 내, 다른 패키지에서 상속받아 자손 클래스에서 접근 가능
default 해당 패키지 내에서만 접근 가능
private 해당 클래스 내에서만 접근 가능

클래스 멤버 변수 초기화 순서에 대해 설명해주세요 
1. static 변수 선언부: 클래스가 로드 될 때 변수가 제일 먼저 초기화된다. 
2. 필드 변수 선언부 : 객체가 생성될 때 생성자 block보다 앞서 초기화 된다. 
3. 생성자 block : 객체가 생성될 때 JVM이 내부적으로 locking

static에 대해서 설명해주세요
static키워드를 사용한 변수나 메소드는 클래스가 메모리에 올라갈 때 자동으로 생성되며
클래스 로딩이 끝나면 바로 사용할 수 있다. 즉 인스턴스 생성 없이 바로 사용가능
모든 객체가 메모리를 공유한다는 특징이 있고, GC관리 영역 밖에 있기 떄문에 
프로그램이 종료될 떄 까지 메모리에 값이 유지된 채로 존재하게 된다. 

static은 자주 변하지 않는 값이나 공통으로 사용되는 값 같은 공용자원에 대한
접근에 있어서 매번 메모리에 로딩하거나 값을 읽어들이는 것보다 일종의 '전역변수'와 
같은 개념을 통해 접근하는 것이 비용도 줄이고 효율을 높일 수 있다. 
인스턴스 생성없이 바로 사용가능하기때문에 프로그램 내에서 공통으로 사용되는 데이터들을
관리할 때 이용한다. 

Inner Class(내부 클래스)의 장점에 대해 설명해주세요
내부 클래스에서 외부 클래스의 멤버에 손쉽게 접근할 수 있다. 
서로 관련 있는 클래스를 논리적으로 묶어서 표현함으로써, 캡슐화를 증가시키고, 코드의
복잡성을 낮출 수 있다.
외부에서는 내부 클래스에 접근할 수 없으므로, 코드의 보안성을 높일 수 있다. 

리플렉션(Reflection)이란 무엇인지 설명해주세요
리플렉션이란 구체적인 클래스 타입을 알지 못해도 그 클래스의 메소드, 타입, 변수들에 접근할
수 있도록 해주는 자바 API이다. 

언제 사용되냐
- 코드를 작성할 시점에는 어떤 다입의 클래스를 사용할지 모르지만, 런타임 시점에 지금 실행되고 있는
- 클래스를 가져와서 실행해야 하는 경우 사용된다. 

프레임워크가 IDE에서 이런 동적인 바인딩을 이용한 기능을 제공한다. InteliJ의 자동완성기능, 
스프링의 어노테이션이 리플렉션을 이용한 기능이라 할 수 있다. 

CheckedExeption 과 UncheckedException의 차이에 대해 설명해주세요
CheckedException은 실행하기 전에 예측 가능한 예외를 말하고, 반드시 예외 처리를
해야 한다. 
IOException, ClassNotFoundException 등
UncheckedException은 실행하고 난 후에 알 수 있는 예외를 말하고, 따로 예외처리를
하지 않아도 된다. 
Exception - RuntimeException - NullPointerException, IndexOutOfBoundsException 등

Optional API에 대해 설명해주세요ㅕ 

개발할 때 가장 많이 발생하는 예외중 하나가 NPE(nullpointException)    이다. 
NPE를 피하려면 null 여부 검사를 필연적으로 하게 되는데 만약 null 검사를 해야하는 
변수가 많은 경우 코드가 복잡해지고 번거롭다. 
하지만 JAVA 8부터 Optional<T>를 제공하여 null로 인한 예외가 발생하지 않도록
도와주고 Optional 클래스의 메소드를 통해 null을 컨트롤할 수 있다. 

컬렉션 프레임워크에 대해 설명해주세요
다수의 데이터를 쉽고 효과적으로 관리할 수 있는 표준화된 방법을 제공하는 클래스의 
집합을 의미한다. 

자바 컬렉션에는 List, Set, Map 인터페이스를 기준으로 여러 구현체가 존재하고, 
이에 더해 Stack, Queue 인터페이스도 존재한다. 

List는 순서가 있는 데이터의 집합이며, 데이터의 중복을 허용한다. 대표적인 구현체로는
ArrayList가 있고, 이는 Vector를 개선한 것이다. 이외에도 LinkedList등의 
구현체가 있습니다. 
Vector, ArrayList, LinkedList, Stack, Qeuue

Set은 순서가 없는 데이터의 집합이며, 데이터의 중복을 허용하지 않습니다. 
대표적인 구현체로는 HashSet이 있고, 순서를 보장하기 위해서는 LinkedHashSet을
사용합니다. 

Map의 key-value구조에서 key대신 value가 들어가 value를 key로 하는 자료구조
HashSet, LinkedHashSet, TreeSet

Map은 키와 값이 한 쌍으로 이뤄져 있고, 키를 기준으로 중복을 허용하지 않으며, 
순서가 없다. key의 순서를 보장하기 위해서는 LinkedHashMap을 사용한다. 
HashMap, TreeMap, HashTable, Properties

Stack객체는 직접 new 키워드로 사용할 수 있으며, Queue인터페이스는 
LinkedList에 new 키워드를 적용해 사용할 수 있다. 

Set과 Map의 타입이 Wrapper class가 아닌 Object를 받을 때 중복 검사는 어떻게
할건지 설명해주세요

HashCode() 메소드를 오버라이딩해서 리턴된 해시코드값이 같은지를 보고 해시코드값이 
다르다면 다른 객체로 판단하고 해시코드값이 같으면 equals() 메소드를 오버라이딩하여
다시 비교한다. 

Vector와 List의 차이를 설명해주세요
벡터는 데이터 삽입시 원소를 밀어내지만 리스트는 노드를 연결만 하기 떄문에, 삽입 삭제
부분에서 리스트가 시간복잡도의 우위를 가진다. 
벡터는 랜덤부분접근이 가능하지만 리스트는 더블링크드리스트로 되어있기 때무에 
랜덤접근이 되지 않는다. 검색적인 측면에는 벡터가 우위에 있다. 

벡터는 리스트와 달리 항상 동기화되는 장점이자 단점을 가지고 있다. 멀티 쓰레드 환경에서
안전한게 객체를 추가하고 삭제할 수 있지만, 단일쓰레드 환경일때도 동기화를 하기 떄문에 
List보다 성능이 떨어진다. 

제너릭에 대해 설명해주세요
제너릭은 데이터의 타입을 하나로 지정하지 않고, 사용할 때마다 범용적이고 포괄적으로 
지정한다는 의미이다. 
제너릭 타입을 사용하므로써 잘못된 타입이 사용될 수 있는 문제를 컴파일 과정에서 
제거할 수 있어 에러는 사전에 방지할 수 있다. 

Java 제너릭 이란?
JAVA 5 부터 제너릭이 추가되었다. 

Java에서 제너릭은 data type을 특정한 type 하나로 지정하지 않고 사용할 떄마다 
바뀔 수 있게 범용적이고 포괄적으로 지정한다 라는 의미이다. 

제너릭 타입은 <> 를 가지는 클래스와 인터페이스를 말한다. 

제너릭을 사용해야 하는 이유
제너릭 타입을 사용함으로써 잘못된 타입이 사용될 수 있는 문제를 컴파일 과정에서 제거할 수 있다. 

실행 시 타입 에러가 나는것보다는 컴파일 시에 에러르 사전에 방지하는 것이 좋다. 
또 제너릭 코드를 사용하면 타입을 국한하기 때문에 요소를 찾아올 때 타입변환을 할 필요가 없어
프로그램 성능이 향상된다. 

final/finally/finalize의 차이를 설명해주세요

final은 클래스,메소드, 변수 , 인자를 선언할 때 사용할 수 있으며, 한번만 
할당하고 싶을 때 사용한다. 
final 변수는 한번 초기화되면 그 이후에 변경할 수 없다. 
final 메소드는 다른 클래스가 이 클래스를 상속할 때 메소드 오버라이딩을 금지한다. 
final 클래스는 다른 클래스에서 이 클래스를 상속할 수 없다. 

finally는 try-catch와 함께 사용되며, try-catch가 종료될 때 finally block
이 항상 수행되기 때문에 마무리 해줘야 하는 작업이 존재하는 경우에 해당하는 코드를 작성해주는
코드 블록입니다. 

finalize는 object클래스에 정의되어있는 메소드이며, GC에 의해 호출되는 메소드로
절대 호출해서는 안되는 메소드이다. GC가 발생하는 시점이 불분명하기 때문에 해당
메소드가 실행된다는 보장이 없고, 

직렬화(Serialize) 에 대해 설명해주세요

시스템 내부에서 사용되는 객체 또는 데이터를 외부의 시스템에서도 사용할 수 있도록 바이트
형태로 데이터 변환하는 기술이며, 반대로 직렬화된 바이트 형태의 데이터를 다시 객체로 변환하는과정을
'역직렬화'라고 합니다. 

(간단히 )JVM의 메모리에 상주(힙 or 스택)되어 있는 객체 데이터를 바이트 형태로 변환하는 기술

SerializeVersionUID를 선언해야 하는 이유에 대해 설명해주세요 
JVM은 직렬화와 역직렬화를 하는 시점의 클래스에 대한 버전 번호를 부여하는데, 만약
그 시점에 클래스의 정의가 바뀌어 있다면 새로운 버전 번호를 할당하게 된다. 
그래서 직렬화할 때의 버전 번호와 역직렬화를 할 때의 버전 번호가 다르면 역직렬화가
불가능하게 될 수 있기 때문에 이런 문제를 해결하기 위해 SerialVersionUID를
사용한다. 

WAS와 WS의 차이를 설명해주세요
WAS 
비즈니스 로직을 넣을 수 있음 
Tomcat, PHP, ASP, NET 등

WS
비즈니스 로직을 넣을 수 없음 
Nginx, Apache 등

Spring Framework에 대해 설명해주세요
스프링 프레임워크는 자바 개발을 편리하게 해주는 오픈소스 프레임워크이다. 

경량 컨테이너로서 자바 객체를 직접 관리
각각의 객체 생성, 소멸과 같은 라이프 사이클을 관리하며 스프링으로부터 필요한 객체를 
얻어올 수 있다. 

제어의 역전(IoC)라는 기술을 통해 어플리케이션의 느슨한 결합을 도모 
컨트롤의 제어권이 사용자가 아닌 프레임워크에 있어서 필요에 따라 스프링에서 사용자의 
코드를 호출한다. 

의존성 주입(DI)을 지원
각각의 계층이나 서비스들 간에 의존성이 존재할 경우 프레임워크가 서로 연결시켜준다. 

관점지향 프로그래밍(AOP)를 지원
트랜잭션이나 로깅, 보안과 같이 여러 모듈에서 공통적으로 사용하는 기능의 경우 해당 기능을
분리하여 관리할 수 있다. 

@RequestBody, @RequestParam, @ModelAttribute의 차이를 설명해주세요
@RequestBody는 클라이언트가 전송하는 JSON 형태의 HTTP body내용을 MessageC
onverter를 통해 JAVA Object로 변환시켜주는 역할을 한다. 
값을 주입하지 않고 값을 변환시키므로 (Reflection을 사용해 할당), 
변수들의 생성자, GEter Setter가 없어도 정상적으로 할당된다. 

@RequestParam은 1개의 HTTP 요청 파라미터를 받기 위해 사용한다. 
@RequestParam은 필수 여부가 true이기 때문에, 
기본적으로 반드시 해당 파라미터가 전송되어야 한다. 전송되지 않으면 400 Error를
유발할 수 있으며, 
반드시 필요한 변수가 아니라면 required의 값을 false로 설정해줘야 한다. 

@ModelAttribute는 HTTP Body내용과 HTTP 파라미터의 값들을 생성자, GEtter
Setter를 통해 주입하기 위해 사용한다. 
값 변환이 아닌 값을 주입시키므로 변수들의 생성자나 Getter, Setter가 없으면
변수들이 저장되지 않는다. 

Spring Boot와 Spring Framework의 차이점을 설명해주세요
가장 큰 차이점은 Auto Configuration의 차이인 것 같습니다. 

Spring은 프로젝트 초기에 다양한 환경설정을 해야하지만 Spring Boot는 
설정으 많은 부분들을 자동화하여 사용자가 편하게 스프링을 활용할 수 있도록 돕는다. 

spring boot starter dependency만 추가해주면 설정은 끝나고, 내장된 톰캣을
제공해 서버를 바로 실행할 수 있다. 

Spring MVC에 대해 설명해주세요

MVC는 Model, View, Controller의 약자이며, 각 레이어간 기능을 구분하는데 
중점을 둔 디자인패턴이다. 

Model은 데이터 관리 및 비즈니스 로직을 처리하는 부분이며(DAO DTO, Service등)

View는 비즈니스 로직의 처리 결과를 통해 유저 인터페이스가 표현되는 구간이다. 
Controller는 사용자의 요청을 처리하고 Model과 View를 중개하는 역할을 한다. 
Model과 View는 서로 연결되어 있지 않기 떄문에 Controller 가 사이에서 통신 
매체가 되어준다. 

DispatcherServelt : 클라이언트에게 요청을 받아 응답까지의 MVC 처리과정을 통제한다.
HandlerMapping: 클라이언트의 요청 URL을 어떤 Controller가 처리할지 결정한다. 
HandlerAdapter: HandlerMapping에서 결정된 핸들러 정보로 해당 메소드를 직접
호출해주는 역할을 한다. 
ViewResolver : Controller의 처리 결과를 생성할 view를 결정한다. 

클라이언트는 URL을 통해 요청을 전송한다. 
2. 디스패처 서블릿은 핸들러 매핑을 통해 해당 요청이 어느 컨트롤러에서 온 것인지 찾는다. 
3. 디스패처 서블릿은 핸들러 어댑터에게 요청의 전달을 맡긴다. 
4. 핸들러 어댑터는 해당 컨트롤러에 요청을 전달한다
5. 컨트롤러는 비즈니스 로직을 처리한 후에 반환할 뷰의 이름을 반환한다
6. 디스패처 서블릿은 뷰 리졸버를 통해 반환할 뷰를 찾는다
7. 디스패처 서블릿은 컨트롤러에서 뷰에 전달할 데이터를 추가한다
8. 데이터가 추가된 뷰를 반환한다

제어의 역전(IoC, Inversion of Control)에 대해 아는대로 설명해주세요
제어의 역전이란 모든 객체에 대한 제어권을 개발자기 아닌 IoC컨테이너에게 넘긴 것을 말한다. 
스프링은 IoC컨테이너에 객체들을 생성하면, 객체끼리 의존성을 주입하는 역할을 하고 
컨테이너에 등록한 객체들을 빈 이라고 한다. 

스프링에서 빈을 등록하는 방법에 대해 말해보세요

1. 가장 쉬운 방법으로 @Component 어노테이션을 사용하는 것이다. 
2. @Controoller @Service @Repository는 모두 @Component를 포함하고 있다. 

설정 클래스를 따로 만들어 @Configuration 어노테이션을 붙이고, 
해당 클래스 안에서 빈으로 등록할 메소드를 만들어 @Bean 어노테이션을 붙여주면 자동으로 
해당 타입의 빈 객체가 생성된다, 

의존성 주입(DI, Dependency Injection)에 대해 아는대로 설명해주세요
의존성 주입은 필요한 객체를 직접 생성하는 것이 아닌 외부로부터 객체를 받아서 사용하는 것이다. 
이를 통해 객체간의 결합도를 줄이고 코드의 재사용성을 높일 수 있다. 

의존성주입은 생성자 주입, 필드 주입, 세터 주입의 3가지 방법이 있다. 
이 주 ㅇSpring에서 가장 권장하는 방법은 생성자를 통한 주입 방법이다. 
그 이유는 1. 순환 참조를 방지 2. 불변성을 가짐 3. 테스트에 용이하기 때문

스프링 빈의 라이프사이클은 어떻게 관리되는지 설명해주세요
먼저 스프링 Bean의 LifeCycle은 다음과 같습니다. 

IOC 컨테이너 생성 스프링 빈 생성
의존관계 주입
초기화 콜백 메소드 호출
사용
소멸 전 콜백 메소드 호출
스프링 종료

스프링은 크게 3가지 방법으로 빈 생명주기 콜백을 관리한다. 
1. 인터페이스
2. 설정 정보에 초기화 메소드, 종료 메소드 지정
3. @PostConstruct, @PreDestroy 어노테이션 지원

Spring Filter와 Interceptor에 대해 설명하고, 사용 예시를 설명해주세요.
필터는 말 그대로 요청과 응답을 거른뒤 정제하는 역할을 합니다.
스프링 컨테이너가 아닌 톰캣과 같은 웹 컨테이너에 의해 관리가 되는 것이고, 스프링 범위 
밖에서 처리된다. DispatcherServelt에 요청이 전달되기 전/후에 url 패턴에 맞는
모든 요청에 대해 부가 작업을 처리할 수 있는 기능을 제공한다. 

사용사례 : 
보안 및 인증/인가 관련작업
모든 요청에 대한 로깅 또는 검사
이미지/ 데이터 압축 및 문자열 인코딩
Spring과 분리되어야 하는 기능

인터셉터는 요청에 대한 작업 전/ 후로 가로채 요청과 응답을 참조하거나 가공하는 역할을 한다.
웹 컨테이너에서 동작하는 필터와 달리 인터셉터는 스프링 컨텍스트에서 동작한다.
Dispatcher Servlet이 Controller를 호출하기 전/ 후에 인터셉터가 끼어들어 
응답을 참조하거나 가공할 수 있는 기능을 제공

사용 사례 : 
세부적인 보안 및 인증/인가 공통작업
API호출에 대한 로깅 또는 검사
Controller로 넘겨주는 정보(데이터)의 가공

관점지향 프로그래밍(AOP)는 무엇이고 언제 사용할 수 있을까요
AOP는 핵심 비즈니스 로직에 있는 공통 관심사항을 분리하여 각각을 모듈화 하는 것을
의미하며 공통 모듈인 인증, 로깅, 트랜잭션 처리에 용이합니다. 

AOP는 핵심 비즈니스 로직에 있는 공통 관심사항을 분리하여 각각을 모듈화 하는 것을 
의미하며 공통 모듈인 인증, 로깅, 트랜잭션 처리에 용이하다. 

핵심 비즈니스 로직에 부가기능을 하는 모듈이 중복되어 분포되어 있을 경우 
사용할 수 있다. 

AOP의 가장 큰 특징이자 장점은 중복 코드 제거, 재활용성의 극대화, 변화수용의 용이성이
좋다는 점이다.

Lombok 라이브러리에 대해 알고있나요? 알고 있다면 롬복이 만드는 메소드들이 생성되는
시점은 언제인가요?

Lombok은 메소드를 컴파일 하는 과정에 개입해서 추가적인 코드를 만들어낸다. 이것을
어노테이션 프로세싱이라고 하는데, 
어노테이션 프로세싱은 자바 컴파일러가 컴파일 단계에서 어노테이션을 분석하고 처리하는
기법을 말한다.
(Lombok라이브러리를 추가할 때 CompileOnly, AnnotationProcessor를 추가하는 이유도 된다.)


서블릿(Servlet) 에 대해 설명해주세요
클라이언트의 요청을 처리하고, 그 결과를 반환하는 Servlet 클래스의 구현 규칙을 지킨
자바 웹 프로그래밍 기술이다. 
Spring MVC에서 Controller로 이용되며, 사용자의 요청을 받아 처리한 후에 결과를 반환한다.
간단히 - 자바를 사용해 웹을 만들기 위해 필용한 기술

서블릿의 동작 방식에 대해 설명해주세요
Client HTTP REquest Container 
1. 사용자가 URL을 입력하면 HTTP REquest가 Servlet Container로 전송된다. 
2. 요청받은 Servlet Container는 HttpServletRequest, HttpServletResponse객체를 생성한다.
3. web.xml을 기반으로 사용자가 요청한 URL이 어느 서블릿에 대한 요청인지 찾습니다.
4. 해당 서블릿에서 service메소드를 호출한 후 GET, POST 여부에 따라 doGet 또는 doPOST를 호출
5. doGet 또는 doPost 메소드는 동적 페이지를 생성한 후 HttpServletResponse객체에 응답을 보낸다.
6. 응답이 끝나면 HttpServletRequest, HttpServletResponse 두 객체를 소멸시킨다.

VO와 BO DAO DTO에 대해 설명해주세요
DAO DB의 데이터에 접근을 위한 객체를 말한다. Repository 또는 Mapper에 해당
BO 여러 DAO를 활용해 비즈니스 로직을 처리하는 객체를 말한다. 
DTO 각 계층간의 데이터 교환을 위한 객체를 말한다. 
VO 실제 데이터만을 저장하는 객체를 말한다.

대용량 트래픽에서 장애가 발생하면 어떻게 대응할 것인가요?
스케일 업을 통해 하드웨어 스펙을 향상 / 스케일 아웃을 통해 서버를 여러대 추가해
시스템을 증가

Spring의 싱글톤 패턴에 대해 설명해주세요 
스프링에서 bean 생성시 별다른 설정이 없으면 기본으로 싱글톤이 적용된다.
스프링은 컨테이너를 통해 직접 싱글톤 객체를 생성하고 관리하는데, 
요청이 들어올 때마다 매번 객체를 생성하지 않고 이미 만들어진 객체를 공유하기 때문에 효율적인 사용이 가능하다. 

static 메소드나 private 생성자 등을 사용하지 않아 객체지향적 개발을 할 수 있다.
테스트하기 편리하다

Spring의 스코프 프로토 타입 빈에 대해 설명해주세요 
프로토타입 빈은 싱글톤 빈과는 달리 컨테이너에게 빈을 요청할 때마다 매번 새로운 객체를 생성하여
반환해준다. 
이렇게 빈의 scope를 간단하게 관리해줄 수 있는 것이 spring의 장점이다. 
빈의 scope 설정은 Scope 어노테이션으로 설저앟며 프로토타입 scope으로 설정하러면
Scope("prototype")와 같이 문자열로 지정해준다. 

@Transactional의 동작 원리에 대해 설명해주세요
@Transcational을 메소드 또는 클래스에 며시하면, AOP를 통해 
Target이 상속하고 있는 인터페이스 또는 Target객체를 상속한 Proxy객체가 생성되며, 
Proxy객


































