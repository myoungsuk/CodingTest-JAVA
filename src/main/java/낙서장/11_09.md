### 11_09

@Transactional의 동작 원리에 대해 설명해주세요 

@Transactional을 메소드 또는 클래스에 명시하면, AOP를 통해 Target이 상속하고 있는
인터페이스 또는 Target객체를 상속한 Proxy객체가 생성되며, Proxy객체의 
메소드를 호출하면 Target 메소드 전 후로 트랜잭션 처리를 수행한다. 

Transactional을 스프링 Bean의 메소드 A에 적용하였고, 해당 Bean의 메소드
B가 호출되었을 때 , B메소드 내부에서 A메소드를 호출하면 어떤 요청 흐름이 
발생하는지 설명해주시오 

프록시는 클라이언트가 타겟 객체를 호출하는 과정에만 동작하며, 타겟 객체의 메소드가
자기 자신의 다른 메소드를 호출할 때는 프록시가 동작하지 않습니다. 
즉 A 메소드는 프록시로 감싸진 메소드가 아니므로 트랜잭션이 적용되지 않은 일반
코드가 수행됩니다. 

A라는 Service 객체의 메소드가 존재하고, 그 메소드 내부에서 로컬 트랜잭션 3개 (
다른 Service) 객체의 트랜잭션 메소드를 호출했다는 의미)가 존재한다고 할 때, 
A 메소드에 @Transactional을 적용하면 어떤 요청 흐름이 발생하는지 설명해주세요
)

트랜잭션 전파 수준에 따라 달라지는데, 만약 기본 옵션인 Required를 가져간다면
로컬 트랜잭션 3개가 모두 부모 트랜잭션인 A에 합류하여 수행됩니다.

그래서 부모 트랜잭션이나 로컬 트랜잭션 3개나 모두 같은 트랜잭션이므로 
어느 하나의 로직에서 문제가 발생하면 전부 롤백이 됩니다. 

JDBC 트랜잭션
자바에서 데이터베이스의 트랜잭션을 시작하는 유일한 방법이다. setAutoCommit(false)는
트랜잭션을 직접 관리할 수 있게 해준다. 
즉, 개발자가 원할 때 커밋 또는 롤백할 수 있다. 
커밋을 한다. 
예외가 발생한 경우 롤백을 한다.

JDBC 트랜잭션의 단점
트랜잭션을 발생해야 하는 경우, 데이터 접근 기능에서 결코 자유롭지 않다 .즉 두 개 이상의 
DB접근해야 하는 작업을 하나의 트랜잭션으로 만들 수 없다. 

Java Transaction API (JTA) 를 이용할 수도 있지만, 
API를 직접 다루는 것은 의도하지 않은 에러 발생 가능성을 높인다. 
기술환경이 변화함에 따라 코드가 달라질 수 있다. 

platformTransactionManager
스프링에서는 platformTransactionManager라는 추상화된 인터페이스를 제공한다.
platformTransactionManager는 TransactionManager의 최상위 인터페이스로, 
인터페이스에서 각자의 환경에 맞는 TransactionManager 클래스를 주입한다. 

예를 들어 , JDBC 및 MyBatis 등의 JDBC기반 라이브러리로 데이터베이스에 
접근하는 경우에 DataSourceTransactionManager를 주입하고, 하이버네이트는
HibernateTransactionManager를 주입한다. 
JPA는 JpaTransactionManager를 주입한다.

@Transactional
일반적으로 많이 사용하는 선언적 트랜잭션 방식이다. 
@Transactional 어노테이션을 사용하고 싶으면 설정에서 
@EnableTransactionManagement를 추가해야 한다.
스프링부트에서는 자동으로 @EnableTransactionManagement설정이 되어있다. 
@Transactional이 있으면 JDBC에서 필요한 코드를 삽입해 준다. 

@Transactional을 이해하려면 Spring AOP에 대한 지식이 있어햐 한다. 

Spring AOP는 일반적으로 두 가지 방식이 잇다. 
JDK Dynamic Proxy를 이용하는 방식과 CGLIB을 이용하는 방식이다.

AOP프록시 생성 과정에서 타겟 객체가 하나 이상의 인터페이스를 구현하고 있는 클래스라면
Dynamic Proxy를 사용하고, 그렇지 않다면 CGLIB을 사용한다. 















































