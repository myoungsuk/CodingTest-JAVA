### 11_09

@Transactional의 동작 원리에 대해 설명해주세요 

@Transactional을 메소드 또는 클래스에 명시하면, AOP를 통해 Target이 상속하고 있는
인터페이스 또는 Target객체를 상속한 Proxy객체가 생성되며, Proxy객체의 
메소드를 호출하면 Target 메소드 전 후로 트랜잭션 처리를 수행한다. 

Transactional을 스프링 Bean의 메소드 A에 적용하였고, 해당 Bean의 메소드
B가 호출되었을 때 , B메소드 내부에서 A메소드를 호출하면 어떤 요청 흐름이 
발생하는지 설명해주시오 

프록시는 클라이언트가 타겟 객체를 호출하는 과정에만 동작하며, 타겟 객체의 메소드가
자기 자신의 다른 메소드를 호출할 때는 프록시가 동작하지 않습니다. 
즉 A 메소드는 프록시로 감싸진 메소드가 아니므로 트랜잭션이 적용되지 않은 일반
코드가 수행됩니다. 

A라는 Service 객체의 메소드가 존재하고, 그 메소드 내부에서 로컬 트랜잭션 3개 (
다른 Service) 객체의 트랜잭션 메소드를 호출했다는 의미)가 존재한다고 할 때, 
A 메소드에 @Transactional을 적용하면 어떤 요청 흐름이 발생하는지 설명해주세요
)

트랜잭션 전파 수준에 따라 달라지는데, 만약 기본 옵션인 Required를 가져간다면
로컬 트랜잭션 3개가 모두 부모 트랜잭션인 A에 합류하여 수행됩니다.

그래서 부모 트랜잭션이나 로컬 트랜잭션 3개나 모두 같은 트랜잭션이므로 
어느 하나의 로직에서 문제가 발생하면 전부 롤백이 됩니다. 

JDBC 트랜잭션
자바에서 데이터베이스의 트랜잭션을 시작하는 유일한 방법이다. setAutoCommit(false)는
트랜잭션을 직접 관리할 수 있게 해준다. 
즉, 개발자가 원할 때 커밋 또는 롤백할 수 있다. 
커밋을 한다. 
예외가 발생한 경우 롤백을 한다.

JDBC 트랜잭션의 단점
트랜잭션을 발생해야 하는 경우, 데이터 접근 기능에서 결코 자유롭지 않다 .즉 두 개 이상의 
DB접근해야 하는 작업을 하나의 트랜잭션으로 만들 수 없다. 

Java Transaction API (JTA) 를 이용할 수도 있지만, 
API를 직접 다루는 것은 의도하지 않은 에러 발생 가능성을 높인다. 
기술환경이 변화함에 따라 코드가 달라질 수 있다. 

platformTransactionManager
스프링에서는 platformTransactionManager라는 추상화된 인터페이스를 제공한다.
platformTransactionManager는 TransactionManager의 최상위 인터페이스로, 
인터페이스에서 각자의 환경에 맞는 TransactionManager 클래스를 주입한다. 

예를 들어 , JDBC 및 MyBatis 등의 JDBC기반 라이브러리로 데이터베이스에 
접근하는 경우에 DataSourceTransactionManager를 주입하고, 하이버네이트는
HibernateTransactionManager를 주입한다. 
JPA는 JpaTransactionManager를 주입한다.

@Transactional
일반적으로 많이 사용하는 선언적 트랜잭션 방식이다. 
@Transactional 어노테이션을 사용하고 싶으면 설정에서 
@EnableTransactionManagement를 추가해야 한다.
스프링부트에서는 자동으로 @EnableTransactionManagement설정이 되어있다. 
@Transactional이 있으면 JDBC에서 필요한 코드를 삽입해 준다. 

@Transactional을 이해하려면 Spring AOP에 대한 지식이 있어햐 한다. 

Spring AOP는 일반적으로 두 가지 방식이 잇다. 
JDK Dynamic Proxy를 이용하는 방식과 CGLIB을 이용하는 방식이다.

AOP프록시 생성 과정에서 타겟 객체가 하나 이상의 인터페이스를 구현하고 있는 클래스라면
Dynamic Proxy를 사용하고, 그렇지 않다면 CGLIB을 사용한다. 

JDK Dynamic Proxy
java.lang에 포함되어 있는 Reflection의 Proxy클래스가 말 그대로 동적으로 생성한다고 하여
Dynamic Proxy 라고 부른다. 타겟의 Interface를 기준으로 Proxy를 생성한다.

CGLIB(Code Generator Library)
스프링부트는 CGLIB가 default다. CGLIB는 클래스의 바이트 코드를 조작하여
프록시 객체를 생성하는 라이브러리이다. CGLIB를 사용하여 인터페이스가 아닌 타겟에 대해서 
프록시를 생성할 수 있다. 

동작 과정
@Transactional을 메소드 똔느 클레스에 명시하면, AOP를 통해 타겟이 상속하고 
있는 인터페이스 또는 타겟을 상속한 프록시 객체가 생성된다. 이때 프록시 객체의 
메소드를 호출하면 타겟 메소드 전 후로 트랜잭션 처리를 수행한다. 

Caller에서 AOP프록시를 탄다. 이때 타겟을 호출하지는 않고 프록시를 호출한다. 
AOP 프록시는 트랜잭션 Advisor을 호출한다. 이 과정에서 커밋이 되거나 롤백이 된다. 
Custom Advisor가 있다면, 트랜잭션 Advisor 실행 전 후로 동작한다. 
Custom Advisor은 타겟 메소드를 호출하여, 비즈니스 로직을 호출한다. 
후에 순서대로 리턴된다. 

트랜잭션 경계 설정 전략
일반적으로 트랜잭션의 시작과 종료는 Service 레이어 내부 메소드에 달려 있다. 
트랜잭션의 경계를 설정하는 방법으로는, 크게 PlatformTransactionManager를 이용하는
트랜잭션을 코드를 통해 임의로 지정하는 방법과 AOP를 이용하여 지정하는 방법으로 나뉜다. 

이 중에서 AOP를 활용한 @Transactional 어노테이션이 주로 사용된다. 

프록시 객체 호출 
Proxy.invoke() 시작
트랜잭션 시작
트랜잭션 전파 설정에 따른 내부 메소드 트랜잭션 처리
트랜잭션 커밋
Proxy.invoke() 종료

정리하자면 Spring AOP 방식 트랜잭션은 메소드 단위로 관리된다. 다시 말해서 
메소드가 끝날때 까지 커밋 또는 커넥션 반환이 이루어지지 않는다. 트랜잭션 대상 메소드
내에서 발생하는 SQL은 동일한 커넥션을 사용한다. 
따라서 처리 시간이 긴 메소드의 경우에는 트랜잭션 단위를 조정해서 
DB LOCK 지속 시간이 지나치게 길어지거나 DB커넥션 풀의 커넥션 개수가 
모자라지 않도록 해야된다. 

선언적 트랜잭션 방식을 사용하는 이유는?
비즈니스 로직이 트랜잭션 처리를 필요로 할 때, 트랜잭션 처리 코드와 비즈니스 로직이
공존한다면 코드 중복이 발생하고 비즈니스 로직에 집중하기 어렵다. 따라서 트랜잭션 처리와 
비즈니스 로직을 분리할 수 있는 선언적 트랜잭션 방식을 자주 사용한다. 

@Transactinal의 동작 원리는 
@Transactional을 메소드 또는 클래스에 명시하면 AOP를 통해 Target이 상속하고 있는
인터페이스 또는 Target객체를 상속한 Proxy객체가 생성되며, Proxy객체의 메소드를
호출하면 Target 메소드 전 후로 트랜잭션 처리를 수행한다. 

@Transactional을 사용할 때 주의할 점은?
Proxy객체의 Target Method가 내부 메소드를 호출하면 실제 메소드가 호출되기
때문에 Inner Method에서 @Transactional 어노테이션이 저용되지 않는 것을
주의해야 한다. 

@Transcational 어노테이션을 붙이면 트랜잭션 처리를 위해 Proxy 객체를 생성하는데
Proxy는 Target Class를 상속하여 생성된다. 따라서 상속이 불가능한 private
메소드의 경우 @Transactional 어노테이션을 적용할 수 없다는 것을 주의해야한다. 

@Transactional에 readOnly 속성을 사용하는 이유에 대해서 설명해주세요
트랜잭션 안에서 수정/삭제 작업이 아닌 ReadOnly 목적인 경우에 주로 사용하며, 
영속성 컨텍스트에서 엔티티를 관리 할 필요가 없기 때문에 readOnly를 추가하는 것으로
메모리 성능을 높일 수 있고, 데이터 변경 불가능 로직임을 코드로 표시할 수 있어
가독성이 높아진다는 장점이 있다. 

JPA N+1 문제와 발생하는 이유 그리고 해결하는 방법을 설명해주세요

N+1이란 1번의 쿼리를 날렸을 때 의도하지 않은 N번의 쿼리가 추가적으로 실행되는 것을
의미한다. 

해결방법: 여러가지 방법이 있지만 가장 많이 사용되는 방법은 Ferch Join을 
사용해 해결하는 방법이다. 

N+1 문제가 발생하는 이유는 연관관계를 가진 엔티티를 조회할 때 한쪽 테이블만 
조회하고 연결된 다른 테이블은 따로 조회하기 때문에 Fetch Join을 사용하면
미리 두 테이블을 Join하여 한 번에 모든 데이터를 가져오기 때문에 
N+1 문제를 애초에 막을 수 있다. 

JPA N+1 문제란 
N+1 문제란 1번의 쿼리를 날렸을 때 의도하지 않은 N번의 쿼리가 추가적으로 실행되는것을
의미한다. 

When 언제 발생하는가?
JPA Repository를 활용해 인터페이스 메소드를 호출할 때 
Who 누가 발생시키는가?
1:N 또는 N:1관계를 가진 엔티티를 조회할 때 발생
How 어떤 상황에 발생되는가?
JPA Fetch 전략이 EAGER 전략으로 데이터를 조회하는 경우
JPA Fetch 전략이 LAZY 전략으로 데이터를 가져온 이후에 연관 관계인 하위 
엔티티를 다시 조회하는 경우 

Why 왜 발생하는가?/
JPA Repository로 find 시 실행하는 첫 쿼리에서 하위 엔티티까지 한 번에 가져오지 않고, 
하위 엔티티를 사용할 때 추가로 조회하기 때문에.
JPQL은 기본적으로 글로벌 Fetch 전략을 무시하고 JPQL만 가지고 SQL을 생성하기 떄문에

EAGER(즉시 로딩) 인 경우 
1. JPQL에서 만든 SQL을 통해 데이터를 조회
2. 이후 JPA에서 Fetch전략을 가지고 해당 데이터의 연관 관계인 하위 엔티티들을 추가 조회
3. 2번 과정으로 N+1 문제 발생

LAZY(지연 로딩)인 경우
1. JPQL에서 만든 SQL으 통해 데이털르 조회
2. JPA에서 Fetch 전략을 가지지만, 지연 로딩이기 때문에 추가 조회는 하지 않음
3. 하지만 하위 엔티티를 가지고 작업하게 되면 추가 조회가 발생하기 때문에 결국
4. N+1 문제 발생

N+1 문제 해결 방법
g해결 방법에는 여러 방법들이 있지만 FetchJoin과 EntityGraph 두 가지 
방법을 알아보자 
1. Fetch Join
N+1 자체가 발생하는 이유는 한쪽 테이블만 조회하고 연결된 다른 테이블은 따로 조회하기
2. 때문이다. 

미리 두 테이블을 JOIN 하여 한 번에 모든 데이터를 가져올 수 있다면 애초에
N+1 문제가 발생하지 않을 것이다. 
그렇게 나온 해결 방법이 FetchJoin 방법이다. 
두 테이블을 JOIN하는 쿼리를 직접 작성하는 것이다. 
다음과 같이 JPQL을 직접 지정해준다. 

Fetch JOin(패치 조인)의 단점
쿼리 한번에 모든 데이터를 가져오기 때문에 JPA가 제공하는 Paging API 사용 불가능
Pageable 사용 불가

1:N 관계가 두 개 이상인 경우 사용 불가
패치 조인 대상에게 별칭 부여 불가능
번거롭게 쿼리문을 작성해야 함

2. EntityGraph
@EntityGraph의 attributePaths는 같이 조회할 연관 엔티티명을 적으면 된다. 

Fetch Join 과 동일하게 JPQL을 사용해 Query문을 작성하고 필요한 연관관계를
EntityGraph에 설정하면 된다. 

JPA와 같은 ORM을 사용하면서 쿼리가 복잡해진 경우에는 어떻게 해결하는게 
좋을까요?

일단 JPA 자체는 정적인 상황에서 사용하는걸 권장하기 때문에 복잡한 쿼리와 
동적인 쿼리에 대한 문제가 발생하게 되는데, 
그럴때는 JPQL과 Querydsl을 사용할 것을 권장하고 있다. 

Restful API는 통신을 Rest 설계 규칙을 잘 지켜서 개발한 API를 Restful한
API라고 한다. 

REST 설계 규칙은 URI는 정보의 자원만 표현해야 하며, 자원의 상태와 행위는 
HTTP Method에 명시하는걸 말한다. 

프레임워크와 라이브러리의 차이에 대해 설명해주세요
이 둘의 차이점은 제어 흐름에 대한 주도궘이 누구에게/ 어디에 있는가에 있습니다. 
프레임워크는 전체적인 흐름을 쥐고 있고, 개발자는 그 안에서 라이브러리에 대한 흐름을
쥐고 있습니다. 
여기서 개발자의 제어권을 프레임워크에게 넘김으로써 신경써야할 것을 줄일 수 있는데, 
이를 제어의 역선 IoC라고 한다. 

Call By Value 와 Call By Reference의 차이점에 대해 설명해주세요

Call By Value(값에 의한 호출) - 인자로 받은 값을 복사하여 처리하는 방식이다. 
장점 - 값을 복사하여 처리하기 때문에 원래의 값이 보존된다. 
단점 - 복사하기 때문에 메모리 사용량이 증가한다. 

Call By Reference(참조에 의한 호출) - 인자로 받은 값의 주소를 참조하여 처리하는 방식이다.
장점 - 복사하지 않고 직접 참조하기에 빠르다. 
단점 - 직접 참조를 하기에 원래의 값이 영향을 받는다. 

그럼 Java에서 어느 부분이 call by value이고 어느 부분이 call by reference에 
해당하나요?

Java는 기본적으로 모든 전달 방식이 Call by Value 입니다.
참조형의 경우 객체의 '주소값'을 매개변수로 전달하니 call by reference가 아니냐는
의문을 가질 수 있지만, 정확하게 말하면 주소값이 아니라 주소를 가리키는 참조값이다. 
또한 주소값 자체를 복사 없이 인자로 전달하는게 아니라 자기 자신이 갖고 있는 값을
복사해서 전달한다. 
결국 기본형 변수나 참조형 변수 모두 자기 자신이 갖고 있는 값을 복사해서 전달하기
때문에 Call by Value이다. 

CORS(교차 출처 리소스 공유, Cross-Origin Resource Sharing)에 대해 설명해주세요
CORS란 도메인이 서로 다른 2개의 사이트가 데이터를 주고받을때 발생하는 문제이다. 

브라우저는 보안 상의 이유로, 스크립트에서 시작한 교차 출처 HTTP 요청을 제한한다. 

따라서 다른 서버의 리소스를 불러오기 위해서는, 그 출처에서 CORS에 대한 내용을
Response의 헤더에 추가해줘야 한다. 

Access-Control-Allow-Origin: 요청을 보내는 페이지의 출처
Access-Control-Allow-Methods: 요청을 허용하는 메소드
Access-Control-Allow-Headers: 요청을 허용하는 헤더
Access-Control-Max-Age : 클라이언트에서 preflight 요청 결과를 저장할 시간

절차지향 프로그래밍과 객체지향 프로그래밍의 차이점에 대해 설명해주세요
절차지향 프로그래밍
물이 위에서 아래로 흐르는 것처럼 순차적인 처리를 중요시하는 프로그래밍 기법이다. 
대표적인 언어로 C언어가 있다. 
컴퓨터의 처리구조와 유사해 실행속도가 빠르다. 
코드의 순서가 바뀌면 동일한 결과를 보장하기 어렵다. 

객체지향 프로그래밍
실제 세계의 사물들을 객체로 모델링하여 개발을 진행하는 프로그래밍 기법이다. 
대표적인 언어로 Java가 있다. 
캡슐화, 상속, 다형성 등과 같은 기법을 이용할 수 있다. 
절차지향 언어보다 실행속도가 느리다. 

절차지향 프로그래밍은 기능중심으로 바라보는 방식으로 "무엇을 어떤 절차로 할 것인가"
가 핵심이 되며, 어떤 기능을 어떤 순서로 처리하는가에 대해 초점을 맞추고, 
객체지향 프로그래밍은 기능이 아닌 객체 중심으로 바라보는 방식으로 "누가 어떤 일을 "할 것인가
가 핵심이며, 객체를 도출하고 각각의 역할을 정의해 나가는 것에 초점을 둔다. 

OAuth 2.0의 흐름에 대해 간단히 설명해주세요

사용자가 클라이언트에게 사용 요청을 보낸다. 
클라는 권한 서버에 부여 승인 코드 요청을 보낸다. 
이후 클라는 권한 서버에서 제공하는 로그인 페이지를 띄워 사용자에게 보여준다. 
사용자가 로그인 하면 권한 서버는 2권한 부여 승인 코드 요청에 전달받은 redirect_url
로 Autorization Code를 전달한다. 
Authorization Code는 권한 서버에서 제공하는 API를 통해 Access Token으로 교환된다. 

동적 쿼리란 무엇이고 언제 동적 쿼리를 사용하나요?
동적 쿼리란 실행시에 특정 조건이나 상황에 따라 쿼리 문장이 변경되어 실행되는 쿼리문을 말합니다. 

컴파일시에 SQL 문장을 확정할 수 없는 경우에 사용합니다. 실행 시점에 따라
where 절에 조건이 달라질 때 사용합니다. 

쿼리문이 변하냐 변하지 않느냐에 따라 정적쿼리/동적쿼리가 됩니다. 

CSRF(Cross-site request forgery)에 대해 설명하고, 이를 막기 위한 방법에 대해
설명해주세요 

사이트 간 요청 위조의 약자로 웹 어플리케이션 취약점 중 하나로 공격자가 의도한대로 
사용자가 행동하게 하여 특정 웹페이지를 보안에 취약하게 한다거나 수정, 삭제 등으 ㅣ
작업을 하게 만든느 공격 방법을 이ㅡ미합니다,

1. 사용자의 요청에 referrer를 확인하여 도메인이 일치하는지 확인하는 방법으로 
2. 공격을 방어

요청 헤더에서 referrer 정보를 확인할 수 있음
같은 도메인에서 들어오는 접속은 허용하나 다른 도메인에서 호출할 때는 차단하는 개념

상태를 변화시키는 POST, PUT 등의 요청에 대해 csrf 토큰이 포함되어야만 요청을 
처리하여 공격을 방어 CSRF 공격과정

옥션 관리자 중 한 명이 권한을 가진채 회사 내에서 작업을 하던 중 메일을 조회한다.
(로그인이 되어있으니 관리자로서의 유효한 쿠기를 가지고 있음)

대칭키, 비대칭키 암호화 방식에 대해 설명해주세요
대칭키와 비대칭키는 양방향 암호화 방식입니다. 

대칭키는 암호화와 복호화에 같은 암호 키를 쓰는 알고리즘입니다. 
이는 중간에 누군가 암호키를 가로채면 정보가 유추될 수 있다는 단점이 있는데 이런 문제를 
보완한 방식이 바로 비대칭키 이다. 

비대칭키는 암호화와 복호화할 때 서로 다른 키를 쓰는 알고리즘이다. 
타인에게 절대 노출되어서는 안되는 개인키와 공개적으로 개방되어있는 공개키를 쌍으로 
이룬 형태입니다. 

TDD의 개념에 대해 설명해주세요
TDD란 작은 단위의 테스트 케이스를 작성하고 그에 맞는 코드를 작성하여 테스트를 통과한
후에 상황에 맞게 리팩토링하는 테스트 주도 개발 방식을 말한다. 

이렇게 반복적인 단계가 진행되면서 자연스럽게 코드의 버그가 줄어들고, 코드는
간결해진다는 장점이 있다. 

TDD는 레드 그린 사이클이라는 3가지 과정을 거칩니다.
1. Red: 어떠한 기능을 검증하는 테스트가 실패하는 코드를 작성하고, 실제로 실패하는지 확인
2. Green: 테스트가 성공하도록 코드를 작성
3. Refactor: 테스트가 성공하면 리팩토링을 통해 중복 코드 제거
4. 이 과정을 반복하면서 개발을 진행

작성해야 하는 이유 
1. 기능의 추가, 변경, 삭제로 인한 영향도를 쉽게 파악 가능
2. 에상하지 못한 오류에 대한 피드백을 위해
3. 좋은 설계로 작성되게끔 코드를 유도
4. 기능 정의의 문서의 역할
5. 실수를 줄여준다.

DDD에서 예기하는 계층과 각각의 역할에 대해 설명해 주세요
표현계층 : 사용자의 요청에 대해 해석하고 응답하는 일을 책임지는 계층
Controller 
client로부터 request를 받고 response를 return 하는 API 정의 
응용 계층(Application Layer) : 비즈니스 로직을 정의하고 정상적으로 수행될 수 
있도록 도메인 계층과 인프라스트럭처 계층을 연결해주는 역할을 하는 계층(Service)
transaction 관리, DTO 변환, 모듈간의 연계를 진행

도메인 계층(Domain layer) : 비즈니스 규칙, 정보에 대한 실질적인 도메인에 대한 
정보를 가지고 있으며 이 모든것을 책임지는 계층(Entity)
Entity를 활용하여 도메인 로직이 진행된다. 
업무 상황을
    
인프라스트럭처 계층 : 외부와의 통신을 담당하는 계층 

Controller, Service, Entity, Repository

MSA가 뭔지 설명해주세요
MSA는 1개의 시스템을 독립적으로 배포 가능한 각각의 서비스로 분할합니다. 
각각의 서비스는 API를 통해 데이터를 주고 받으며 1개의 큰 서비스를 구성합니다. 

모든 시스템의 구성요소가 한 프로젝트에 통합되어 있는 Monolithic Architecture와
의 한계점을 극복하고자 등장하게 되었다. 

장점
일부 서비스에 장애가 발생해도 전체 서비스에 영향을 끼치지 않는다. 
각각의 서비스들은 서로 다른 언어와 프레임워크로 구성될 수 있다. 
서비스의 확장이 용이하다. 

단점
서비스가 분리되어 있어 테스트나 트랜잭션 처리 등이 어렵다. 
서비스 간에 API로 통신하기 때문에 그에 대한 비용이 발생한다. 
서비스 간의 호출이 연속적이기 때문에 디버깅 및 에러 트레이싱이 어렵다. 


데이터베이스의 특징에 대해 설명해주세요

1. 실시간 접근성 : 비정형적인 질의에 대하여 실시간 처리에 의한 응답이 가능해야함
2. 지속적인 변화 : 데이터베이스의 상태는 동적이다ㅏ. 즉 새로운 데이터의 삽입 삭제 
3. 업데이트로 항상 최신의 데이터를 유지해야 한다. 
4. 동시공용 데이터베이스는 서로 다른 목적을 가진 여러 응용자들을 위한 것이므로 
5. 다수의 사용자가 동시 같은 내용의 데이터를 이용할 수 있어야 한다. 
내용에 의한 참조 : 데이터베이스에 있는 데이터를 참조할 때 데이터 레코드의 주소나 

위치에 의해서가 아니라 사용자가 요구하는 데이터 내용으로 찾습니다. 
데이터베이스 언어 (DDL, DML, DCL)에 대해 설명해주세요 

DDL : 데이터베이스 구조를 정의, 수정, 삭제하는 언어 alter create, dro
DML 데이터베이스내의 자료 검색, 삽입, 갱신, 삭제를 위한 언어
DCL 데이터에 대해 무결성 유지, 병행 수행 제어, 보호와 관리를 위한 언어
commit, rollback, grant, revoke

SELECT 쿼리의 수행 순서를 알려주세요 
FROM 각 테이블을 확인한다
ON 조인 조건을 확인한다
JOIN 조인이 실행되어 데이터가 SET으로 모아지게 된다. 서브쿼리도 함께 포함되어있어 임시 테이블을 만들 수 있게 도와준다.
WHERE 데이터셋을 형성하게 되면 WHERE 조건이 개별 행에 적용된다. WHERE 절의 제약 조건은 FROM 절로 가져온 데이블에 적용될 수 있다. 
GROUP BY where 조건 적용 후 나머지 행은 GROUP BY절에 지정된 열의 공통 값을 기준으로 그룹화 된다. 쿼리에 집계 기능이 있는 경우에만 이 기능을 사용해야함

HAVING
Group by 절이 쿼리에 있을 경우 Having 절의 제약조건이 그룹화된 행에 적용된다.

SELECT
select에 표현된 식이 마지막으로 적용된다.

DISTINCT
표현된 행에서 중복된 행은 삭제

ORDER BY
LIMIT

트리거에 대해 설명해주세요 
트리거는 특정 테이블에 대한 이벤트에 반응해 INSERT, DELETE UPDATe 같은 DML 문이
수행되었을 때, 데이터베이스에서 자동으로 동작하도록 작성된 프로그램 입니다. 

사용자가 직접 호출하는것이 아닌, 데이터베이스에서 자동적으로 호출한다는것이 가장 큰
특징이다. 

Index에 대해 설명해주시고 장/단점에 대해 아는대로 말해주세요
Index란 테이블을 처음부터 끝까지 검색하는 방법인 FTS(Full Table Scan) 과는 달리
인덱스를 검색하여 해당 자료의 테이블을 액세스하는 방법이다. 

예를 들어, DB를 책으로 비유하면 데이터는 책의 내용일 것이고, 데이터가 저장된 레코드의 주소는
index 목록에 있는 페이지 번호일 것이다. 
인덱스는 항상 정렬된 상태를 유지하기때문에 원하는 값을 검색하는데 빠르지만 , 
새로운 값을 추가하거나 삭제, 수정하는 경우에는 쿼리문 실행 속도가 느려진다. 
즉, 인덱스는 데이터의 저장 성능을 희생하고 그대신 데이터의 검색 속도를 
높이는 기능이라 할 수 있다. 

정규화에 대해 설명해주세요
하나의 릴레이션에 하나의 의미만 존재하도록 릴레이션을 분해하는 과정이며, 데이터의 일관성, 
최소한의 데이터중복, 최대한의 데이터 유연성을 위한 방ㅂ버이다. 

제1정규형 : 테이블의 칼럼이 원자값 하나의 값을 갖도록 분해합니다. 
제2정규형 : 제1정규형을 만족하고, 기본키가 아닌 속성이 기본키에 완전 함수 종속이도록 분해합니다. 
여기서 완전 함수 종속이란 기본키의 부분집합이 다른 값을 결정하지 않는 것을 의미

제3정규형 : 제2 정규형을 만족하고, 이행적 함수 종속을 없애도록 분해합니다. 
여기서 이행적 종속이란 A -> B b -> C가 성립할 때 A-> C가 성립되는 것을 의미

BCNF 정규형 : 제3정규형을 만족하고, 함수 종속성 X->Y가 성립할 때 모든 결정자
X가 후보키가 되도록 분해합니다. 

정규화 장점, 단점
장점 
1. 데이터베이스 변경 시 이상현상이 발생하는 문제점을 해결할 수 있다.
2. 데이터베이스 구조 확장 시 정규화된 데이터베이스는 그 구조를 변경하지 않아도 되거나 일부만 변경해도 된다. 

단점
릴레이션의 분해로 인해 릴레이션 간의 연산(JOIN 연산)이 많아진다. 이로인해 질의에 대한 응답 시간이 느려질 수 있다. 
정규화를 수행한다는 것은 이상현상을 제거하는 것이다. 데이터의 중복 속성을 제거하고 결정자에 의해 동일한 
의미의 일반 속성이 하나의 테이블로 집약되므로 한 테이블의 데이터 용량이 최소화되는 효과가 있다. 
따라서 정규화된 테이블은 데이터를 처리할 때 속도가 빨라질 수도 있고 느려질 수도 있느 ㄴ특성이 있다. 

이상 현상의 종류에 대해 설명해주세요
이상 현상은 테이블을 설계할 때 잘못 설계하여 데이터를 삽입, 삭제, 수정할 때 생기는 논리적 오류를 말한다. 

1. 삽입 이상 : 자료를 삽입할 때 특정 속성에 해당하는 값이 없ㅇ NULL을 입력해야 하는 현상
2. 갱신 이상 : 중복되니 데이터 중 일부만 수정되어 데이터 모순이 일어나는 현상
3. 삭제 이상 : 어떤 정보를 삭제하면, 의도하지 않은 다른 정보까지 삭제되어버리는 현상

이러한 현상을 예방하고 효과적인 연산을 하기 위해 데이터 정규화를 한다. 

SQL 인젝션이란 공격자가 악의적인 의도를 갖는 SQL 구문을 삽입하여 데이터베이스를 
비정상적으로 조작하는 코드 인젝션 공격 기법이다. 

방어 및 방지하기 위해선
1. 입력값을 검증하여 사용자의 입력이 쿼리에 동적으로 영향을 주는 경우 입력된 값이
2. 개발자가 의도한 값 인지 검증한다. 

저장 프로시저를 사용한다. 
사용하고자 하는 Query에 미리 형식을 지정하는 것을 말한다. 지정된 형식의 데이터가 아니면 
쿼리가 실행되지 않기 때문에 보안성이 크게 향상한다. 

RDBMS는 모든 데이터를 2차원 테이블 형태로 표현한다. 
장점 : 스키마에 맞춰 데이터를 관리하기 때문에 데이터의 정합성을 보장할 수 있다. 
단점 : 시스템이 거질 수록 쿼리가 복잡해지고 성능이 저하되며 Scale-out이 어렵다. 

트랜잭션이란 무엇인지 설명해주세요
트랜잭션은 작업의 완전성을 보장해준다. 
즉 작업들을 모두 처리하거나 처리하지 못할 경우 이전 상태로 복구하여 작업의 일부만 적용되는 
현상이 발생하지 않게 만들어주는 기능이다. 
하나의 트랜잭션은 commit 되거나 rollback 된다. 

트랜잭션의 ACID 에 대해 설명해주세요
Atomicity
Consistency
Isolation
Durability

DB락에 대해 설명해주세요
DB Lock은 트랜잭션 처리의 순차성을 보장하기 위한 방법이다. 
공유락(LS, Shared Lock) Read Lock라고도 하는 공유락은 트랜잭션이 읽기를 하 ㄹ때
사용하는 락이며, 

베타락은 데이터를 변경할 때 사용하는 락이다. 

Elastic Search의 키워드 검색과 RDBMS 의 LIKE 검색의 차이에 대해 설명해주세요
RDBMS는 단순 텍스트매칭에 대한 검색만을 제공해 동의어나 유의어 같은 검색은 불가능하다. 

하지만 엘라스틱 서치는 동의어나 유의어를 활용한 검색이 가능하며, 비정형 데이터의 색인과 
검색이 가능하고, 역색인 지원으로 매우 빠른 검색이 가능하다. 

옵티마이저에 대해 아는대로 말해주세요
옵티마이저는 SQL을 가장 빠르고 효율적으로 수행할 최적의 처리 경로를 생성해주는 
dBMS 내부의 핵심 엔진이다. 
컴퓨터의 두뇌가 CPU인 것 처럼 DBMS의 두뇌는 옵티마이저라고 할 수 있다. 
개발자가 SQL을 작성하고 실행하면 즉시 실행되는 것이 아니라 옵티마이저라는 곳에서 
"이 쿼리문을 어떻게 실행시키겠다.!" 라는 여러가지 실행 계획을 세우고, 최고의 

DB튜닝이 무엇인지 그리고 튜닝의 3단계에 대해 설명해주세요
DB튜닝이란 DB의 구조나, DB자체, 운영체제등을 조정하여 DB시스템의 전체적인 성능을
개선하는 작업을 말한다. 
튜닝은 DB설계 튜닝 DBMS 튜닝 SQL 튜닝 단계로 진행할 수 있다. 

1단계 - DB 설계 튜닝(모델링 관점)
DB 설계 단계에서 성능을 고려하여 설계
데이터 모델링, 인덱스 설계
데이터파일, 테이블 스페이스 설계
데이터베이스 용량 산정
튜닝 사례 - 반정규화 , 분산파일배치

2단계 DBMS튜닝(환경 관점)
성능을 고려하여 메모리나 블록 크기 지정
CPU 메모리 I/O에 관한 관점

튜닝 사례 - Buffer 크기 , Cache 크기

3단계 SQL 튜닝(App 관점)
SQL 작성 시 성능 고려
Join, Indeing, SQL Execution Plan
튜닝 사례 - Hash / Join

inner join과 outer join의 차이를 설명해주세요
inner join은 서로 연관된 내용만 검색하는 조인 방법이다. 
A와 B에 대해 수행하는 것은, A와 B의 교집합을 말한다. 벤 다이어그램으로 그렸을 때 
교차되는 부분이다. 

outer join은 한 쪽에는 데이터가 있고 한 쪽에는 데이터가 없는 경우, 데이터가 
있는 쪽의 내용을 전부 출력하는 방법이다. 
A와 B에 대해 수행하는 것은, A와 B의 합집합을 말한다. 벤 다이어그램으로 그렸을 때
합집합 부분이다. 

outer join에는 left outer join right outer join full outer join 이 있다. 

group by의 역할에 대중복
데해 설명해주세요
Group by 는 group by 명령어를 통해 특정 칼럼을 기준으로 연산한 결과를 집계 키로
정의하여 그룹을 짓는 역할을 한다. 
집합 연산자는 count, sum avg, max, min등이 있고, distinct와 같이 중복 
데이터를 제거하는 특징이 있다. 

그룹화 
groupt by 명령어를 통해 특정 칼럼을 기준으로 그룹화 할 수 있다. 
그룹화를 하면 조회된 데이터의 통게를 내기 위한 집계함수를 사용하기에 용이해진다. 

위와 같은 테이블이 있을 때, 아래는 name 칼럼을 기준으로 그룹화해 집계함수 
를 하는 예지를 보여준다. 

delete, truncate, drop의 차이를 설명해주세요
delete는 데이터는 지우지만 테이블 용량은 줄어들지 않고 원하는 데이터만 골라서 지울 
수 있다. 삭제 후 되돌릴 수 있다. 

truncate는 전체 데이터를 한번에 삭제하는 방식이다. 테이블 용량이 줄어들고 
인덱스 등도 삭제되지만 테이블은 삭제할 수 없고 삭제 후 되돌릴 수없다. 

drop은 테이블 자체를 완전이 삭제하는 방식 이다. 삭제 후 되돌릴 수 없다. 

데이터베이스 클러스터링과 리플리케이션의 차이에 대해 설명해주세요
클러스터링이란 여러 개의 DB를 수평적인 구조로 구축하는 방식이다. 동기 방식으로 사용되며, 
다음과 같은 장단점이 있다. 

장점 : 
DB간의 데이터를 동기화하여 항상 일관성있는 데이터를 얻을 수 있다. 
1개의 DB가 죽어도 다른 Db가 살아있어서 시스템을 장애없이 운영할 수 있다. 
기존에 하나의 DB서버에 몰리던 부하를 여러곳으로 분산시킬 수 있다. 로드 밸런싱

단점 : 
저장소 하나를 공유하면 병목현상이 발생할 수 있다. 
병목현상 : 전체 시스템이 성능이나 용량이 하나의 구성요소로 인해 제한을 받는 현상이다. 
서버를 동시에 운영하기 위한 비용이 많이 든다. 

리플리케이션은 여러 개의 DB를 권한에 따라 수직적인 구조로 구축하는 방식이다. 비동기 
방식으로 사용되며, 다음과 같은 장단점이 있다. 

장점 : 
DB요청의 대부분이 읽기 작업이기 때문에 Replication만으로 충분히 성능을 높일 수 있다. 
비동기 방식으로 운영되어 지연 시간이 거의 없다. 

단점 : 
노드들간 데이터 동기화가 보장되지 않아 일관성있는 데이터를 얻지 못할 수 있다. 
Master DB가 다운되면 복구 및 대처가 까다롭다. 

Having 과 Where의 차이를 설명해주세요
having은 그룹을 필터링 하는데 사용되고 where은 개별 행을 필터링하는데 사용된다. 

집계 함수는 having절과 함께 사용할 수 있으나, where 절은 사용할 수없다.

having은 그룹화 또는 집계가 발생한 후 필터링하는데 사용되고 , 
where은 그룹화 또는 집계가 발생하기 전에 필터링하는데 사용된다. 

JOIN에서 ON과 WHERE의 차이를 설명해주세요
ON이 WHERE보다 먼저 실행되어 JOIN을 하기 전에 필터링을 하고 
WHERE은 JOIN을 한 후에 필터링을 합니다. 

Arrays(List)의 가장 큰 특징과 그로 인해 발생하는 장점과 단점에 대해 설명해주세요
Array의 가장 큰 특징은 순차적으로 데이터를 저장한다는 점이다. 
데이터에 순서가 있기 때문에 0부터 시작하느 ㄴindex가 존재하며, index를 사용해 
특정 요소를 찾고 조작이 가능하다는 것이 Array의 장점이다. 
순차적으로 존재하는 데이터의 중간 요소가 삽입되거나 삭제되는 경우 그 뒤의 모든 
요소들을 한 칸씩 뒤로 밀거나 당겨줘야 하는 단점도 있다. 
이러한 이유로 Array는 정보가 자주 삭제되거나 추가되는 데이터를 담기에는 적절치 않다. 
Array를 적용시키면 좋을 데이터의 예를 구체적으로 들어주세요 

Array를 적용시키면 좋은 예로 주식 차트가 있다. 
주식 차트에 대한 데이터는 요소가 중간에 새롭게 추가되거나 삭제되는 정보가 아니며, 
날짜별로 주식 가격이 차례대로 저장되어야 하는 데이터다. 
즉 순서가 굉장히 중요한 데이터이므로 Array와 같이 순설를 보장해주는 자료구조를 사용하는것이
좋다. 

Stack 과 Queue, Tree와 Heap의 구조에 대해 설명해주세요
Stack과 Qeueu는 선형 자료구조의 일종이며, Array와 LinkedList로 구현할 수 있다. 
Stack은 후입선출 
큐는 선입선출방식이다. 

Tree는 스택과 큐와 같은 선형 구조가 아닌 비선형 자료구조이며 계층적 관계를 표현하기에 적합하다. 
Heap은 최댓값 또는 최솟값을 찾아내는 연산을 쉽게 하기 위해 고안된 구조로, 
각 노드의 키값이 자식의 키값보다 작지 않거나 그 자식의 키값보다 크기 않은 완전이진트리입니다. 

Stack 과 Qeue의 실사용 예를 간단히 설명해주세요

Stack - 자바의 Stack 메모리 영역
지역변수와 매개변수 데이터 값이 저장되는 공간이며, 메소드 호출시 메모리에 할당되고 
종료되면 메모리가 해제되며, LIFO 구조를 가진다. 

Queue - OS의 스케줄러
자원의 할당과 회수를 하는 스케줄러 역할을 큐가 할 수 있다. 
메모리에 적재된 다수의 프로세스 중 어떤 프로세스에게 자원을 할당할 것인가 그 순서를 
결정하는 것이 자원의 효율적인 사용에 있고, 가장 단순한 형태의 스케쥴링 정책이 
선입선처리 즉 큐라고 볼 수 있다. 

public class Stack {
private static int MAX_STACK_SIZE = 10;
private int top;
private int[] data = new int[MAX_STACK_SIZE];

public Stack() {{
top = -1;
}

public void push(int data_) throws exception{
if (isFull()) {
throw new Exception ("스택이 가득 찼습니다");
}
data[++top] = data_;
}

Priority Queue(우선순위 큐)에 대해 설명해주세요.
우선순위 큐는 들어간 순서에 상관없이 우선순위가 높은 데이터를 먼저 꺼내기 위해
고안된 자료구조이다. 
우선순위 큐 구현 방식에는 배열, 연결 리스트, 힙이 있고, 그중 힙 방식이 worst case
라도 시간복잡도 O(logN)을 보장하기 때문에 일반적으로 완전 이진트리 형태의 힙을 이용해
구현한다. 

Array와 ArrayList의 차이점에 대해 설명해주세요
Array는 크기가 고정적이고, ArrayList는 크기가 가변적입니다. 
Array는 초기화 시 메모리에 할당되어 ArrayList보다 속도가 빠르고, 
ArrayList는 데이터 추가 및 삭제 시 메모리를 재할당하기 때문에 속도가 Array보다 느립니다. 

Array는 primitive type과 reference type을 모두 담을 수 있지만, ArrayList는 reference type만 담을 수 있습니다.

Array와 LinkedList의 장/단점에 대해 설명해주세요
Array는 인덱스(index)로 해당 원소에 접근할 수 있어 원소으 인덱스 값을 알고 있으면
엄청 빨리 접근할 수 있다. 
하지만 삽입 또는 삭제의 과정에서 각 원소들을 shift해줘야 하는 비용이 생겨 이 경우
시간복잡도느 ㄴO(n)이 된다는 단점이 있다. 

이 문제점을 해결하기 위한 자료구조가 LinkedList이다. 각각의 원소들은 자기 자신다음에
어떤 원소인지를 기억하고 있기 때문에 이 부분만 다른 값으로 바꿔주면 삽입과 삭제를 O(1)fh 
해결할 수 있다. 

하지만 LinkedList는 원하는 위치에 한 번에 접근할 수 없다는 단점이 있다. 
원하는 위치에 삽입을 하고자 하면 원하는 위치를 Search과정에 있어서 첫번째
원소부터 다 확인해봐야 합니다. 

LinkedList는 삽입과 삭제가 빠르지만 검색이 느리다. 




























