### 11_10

Having과 where의 차이를 설명해주세요
having은 그룹을 필터링 하는데 사용되고, where은 개별 행을 필터링하는데 사용됩니다. 

집계함수 (Count, sum, AVG, MAX, MIN)은 having 절과 함께 사용할 수 있으나, 
where 절은 사용할 수 없다. 
집계함수를 사용할 수 있는 group by 절보다 where 절이 먼저 수행

having은 그룹화 또는 집계가 발생한 후 필터링하는데 사용되고
where은 그룹화 또는 집계가 발생하기 전에 필터링하는데 사용된다. 

JOIN에서 ON과 WHERE의 차이를 설명해주세요
ON이 WHERE보다 먼저 실행되어 JOIN을 하기 전에 필터링을 하고 
WHERE은 JOIN을 한 후에 필터링을 한다. (JOIN을 한 결과에서 WHERE조건절로 필터링이 이뤄진다)

해시 테이블과 시간복잡도에 대해 설명해주세요
해시 테이블은 (Key, Value)로 데이터를 저장하는 자료구조 중 하나로 빠르게 데이터를
검색할 수 있는 자료구조이다. 
빠른 검색 속도를 제공하는 이유는 내부적으로 배열을 사용하여 데이터를 저장하기 떄문이다. 
각 key값은 해시함수에 의해 고유한 index를 가지게 되어 바로 접근할 수 있으므로 
평균 O(1)의 시간 복잡도로 데이터를 조회한다. 하지만 index값이 충돌이 
발생한 경우 Chaining에 연결된 리스트들까지 검색해야 하므로 
O(N)까지 증가할 수 있다. 

Hash Map 과 Hash Table의 차이점에 대해 설명해주세요
동기화 지원 여부와 null 값 허용 여부의 차이가 있습니다
해시 테이블 
병렬 처리를 할 때 (동기화를 고려해야 하는 상황) Thread-safe 하다
null 값을 허용하지 않는다.

해시 맵
병렬처리를 하지 않을 때 (동기화를 고려하지 않아도 되는 상황) Thread-safe 하지 않다
Null 값을 허용한다. 

BTS(Binary Search Tree)와 Binary Tree에 대해 설명해주세요

이진트리는 자식 노드가 최대 두 개인 노드들로 구성된 트리이고, 
이진 탐색 트리는 이진 탐색과 연결 리스트를 결합한 자료구조입니다. 
이진탐색의 효율적인 탐색 능력을 유지하면서, 빈번한 자료 입력과 삭제가 가능하다는 
장점이 있다. 

이진탐색트리는 왼쪽 트리의 모든 값은 반드시 부모 노드보다 작아야 하고, 오른쪽 트리의 값은
부모 노드보다 커야 하는 특징이 있습니다. 
이진탐색트리는 왼쪽 트리의 모든 값은 반드시 부모 노드보다 작아야 하고, 오른쪽 트리의
값은 부모 노드보다 커야하는 특징이 있습니다. 

이진 탐색 트리의 탐색 연산은 트리의 높이에 영향을 받아 높이가 h일 때 시간복잡도는
O(h)이며, 
트리의 균형이 한쪽으로 치우쳐진 경우 worst case가 되고 O(n)의 시간 복잡도를 가진다. 
이런 worst case를 막기 위해 나온 기법이 Red-Block Tree이다. 

RBT에 대해 설명해주세요
RBT는 BST를 기반으로 하는 트리 형식 자료구조이며, RBT는 BST의 삽입, 삭제 
연산 과정에서 발생할 수 있는 문제점을 해결하기 위해 만들었다. 
BST를 기반으로 하기 때문에 BST의 특징을 모두 갖는다. 

노드의 Child가 없을 경우 Child를 가리키는 포인터는 NIL 값을 저장한다. 
이러한 NIL들을 Leaf node로 간주한다. 

모든 노드를 빨간색 또는 검은색으로 색칠하며, 연결된 노드들은 색이 중복되지 않는다. 

동적 계획법(DP, Dynamic Programming)에 대해 설명해주세요
주어진 문제를 풀기 위해, 문제를 여러 개의 하위 문제로 나누어 푸는 방법을 말한다. 
동적 계획법에서는 어떤 부분 문제가 다른 문제들을 해결하는데 사용될 수 있어, 
답으 ㄹ여러버 ㄴ계산하는 대신 한번만 계산하고 그 결과를 재활용하는 
메모이제이션 기법으로 속도를 향상시킬 수 있다. 

동적 계획법이 갖는 2가지 조건은 무엇인가요?
1. 중복되는 부분 문제
중복되는 부분 문제는 나눠진 부분 문제가 중복되는 경우로, 메모이제이션 기법을 사용해 
2. 중복 계산을 없앱니다. 
최적 부분 구조 
3. 최적 부분 구졸르 가진다는 것은 전체 문제의 최적해가 부분 문제의 
4. 최적해들로써 구성된다는 것이다. 

버블 정렬 에 대해 설명해주세요

버블 정렬은 서로 인접한 두 원소를 비교하여 정렬하는 알고리즘입니다. 
0번 인덱스부터 n-1번 인덱스까지 n번까지의 모든 인덱스를 비교하며 정렬합니다. 
시간복잡도는 O(n^2)이며, 최선의 경우 O(n)의 시간복잡도를 가집니다.

선택 정렬에 대해 설명해주세요
선택 정렬은 첫 번째 값을 두번째 부터 마지막 값까지 차례대로 비교하여 최솟값을 찾아
첫 번째에 놓고, 두 번째 값을 세 번째 부터 마지막 값 까지 비교하여 최솟값을 찾아 
두 번째 위치에 놓는 과정을 반복하며 정렬하는 알고리즘입니다. 
시간복잡도는 O(n^2)이며, 최선의 경우 O(n^2)의 시간복잡도를 가집니다.

삽입 정렬
삽입 정렬은 두 번째 값부터 시작해 그 앞에 존재하는 원소들과 비교하여
삽입할 위치를 찾아 삽입하는 정렬 알고리즘입니다. 
평균 시간복잡도는 O(n^2)이며, 최선의 경우 O(n)의 시간복잡도를 가집니다.

힙 정렬에 대해 설명해주세요
힙 정렬은 주어진 데이터를 힙 자료구조로 만들어 최댓값 또는 최솟값부터 하나씩 꺼내서
정렬하는 알고리즘이다. 
힙 정렬이 가장 유용한 경우는 전체를 정렬하는 것이 아니라 가장 큰 값 몇개만을 필요로
하는 경우이다. 시간 복잡도는 O(nlogn)입니다. 

병합 정렬에 대해 설명해주세요
병합 정렬은 주어진 배열을 크기가 1인 배열로 분할하고 합병하면서 정렬을 진행하는 분할/정복
알고리즘입니다. 시간 복잡도는 O(nlogn)입니다. 

퀵 정렬에 대해 설명해주세요
퀵 정렬은 빠른 속도를 자랑하는 분할 정복 알고리즘 중 하나로 피봇을 설정하고 
피봇보다 큰 값과 작은 값으로 분할하여 정렬 합니다. 
병합정렬과 달리 리스트를 비 균등하게 분할합니다. 
시간복잡도는 O(nlogn)이며, worst case경우 O(n^2)까지 나빠질 수 있습니다. 

허프만 코딩에 대해 설명해주세요
허프만 코딩은 문자의 빈도 수를 가지고 압축하는 과정을 말하며 접두부 코드와 최적 코드를 사용합니다. 
접두부 코드 : 각 문자에 부여된 이진 코드가 다른 이진 코드의 접두부가 되지 않는 코드 
최적 코드 : 인코딩된 메시지의 길이가 가장 짧은 코드 

재귀 알고리즘에 대해 설명해주세요
재귀 알고리즘이란 함수 내부에서 함수가 자기 자신을 또 다시 호출하여 문제를 해결하는
알고리즘입니다. 자기자신을 계속해서 호출하여 끝없이 반복되게 하므로 
반복을 중단할 조건이 반드시 필요합니다. 

피보나치 수열의 N번째 값을 구하는 메소드에 대해 각각 재귀 와 반복문으로 손코딩 해주세요

private static int recursiveFibonacci(int index){
if( index <= 2) {
return 1;
return recursiveFibonacci(index - 1) + recursiveFibonacci(index - 2);
}

private static int loopFibonacci(int index){
int answer = 1;
int before = 1;
int temp = 0;
for(int i = 2; i < index; i++){
temp = answer;
answer += before;
before = temp;
}
return answer;
}

팩토리얼의 N번째 값을 구하는 메소드에 대해 각각 재귀와 반복문으로 손코딩 해주세요

private static int 

알고리즘을 생각하세요
sorting 
divide and conquer
dp / memoization
greediness
recursion
algoriths assoicated with data structures

데이터 구조를 생각하시오
Array
stack/queue
hashset/ hashmap/hasdhtable/dictionary
tree/binary tree
heap
graph

HTTP 프로토콜에 대해 설명해주세요
HTTP란 데이터를 주고 받기 위한 프로토콜이며 서버 클라이언트 모델을 따른다. 

HTTP는 상태 정보를 저장하지 않는 Stateless의 특징과 클라이언트의 요청에 맞는
응답을 보낸 후 연결을 끊는 Connectionless의 특징을 가지고 있다. 
장점
통신간의 연결 상태 처리나 상태 정보를 관리할 필요가 없어 서버 디자인이 간단하다. 
각각의 HTTP 요청에 독립적으로 응답만 보내주면 ok

단점
이전 통신의 정보를 모르기 때문에 매번 인증을 해줘야 한다. 
이를 해결하기 위해 쿠키나 세션을 사용해서 데이터를 처리한다. 

HTTP와 HTTPS의 차이점은 무엇인가요?
HTTP는 평문 데이터를 전송하는 프로토콜이기 때문에, HTTP로 중요한 정보를 주고 받으면
제 3자에 의해 조회될 수 있다. 
이러한 문제를 해결하기 위해 HTTP 암호화가 추가된 프로토콜이 HTTPS이다. 

HTTPS는 SSL의 껍질을 덮어쓴 HTTP라고 할 수 있다. 
SSL은 웹서버와 브라우저 사이의 통신을 암호화하는 과정을 말한다.
HTTP는 원래 TCP와 직접 통신했지만, HTTPS에서 HTTP는 SSL와 통신하고 
SSL이 TCP와 통신함으로써 암호화와 증명서, 안정성ㅇ 보호르르 이용할 수 있게 된다. 

쿠키와 세션의 차이점에 대해 말해주세요
쿠키는 사용자의 컴퓨터에 저장하는 작은 기록 정보 파일이다. HTTP에서 클라이언트의
상태 정보를 PC에 저장했다가 필요시 정보를 참조하거나 재사용할 수 있다. 

세션은 일정 시간동안 같은 사용자로부터 들어오는 일련의 요구를 하나의 상태로 보고, 그 상태를
유지시키는 기술이다. 
즉, 방문자가 웹 서버에 접속해 있는 상태를 하나의 단위로 보고 그것을 세션이라고 한다. 

쿠키 세션
저장위치 클라이언트 접속자 PC 웹서버
저장형태 텍스트 파일 / 오브젝트
만료시점 쿠키 저장시 설정 / 브라우저 종료시 삭제
사용하는 자원(리소스) 클라이언트 리소스 / 웹 서버 리소스
용량 제한 총 300개 하나의 도메인 당 20ro 하나의 쿠키 당 4kb / 서버가 허용하는 한 용량제한 없음
속도 세션보다 빠름 / 쿠키보다 느림
보안 세션보다 안좋음 / 쿠키보다 좋음

Stateless 프로토콜
커넥션을 끊는 순간 클라이언트와 서버의 통신이 끝나며 상태 정보는 유지하지 않는 특성이 있다. 
클라이언트와 첫 번째 통신에서 데이터를 주고 받았다 해도, 두 번째 통신에서 이전 데이터를 유지하지 않는다. 
하지만 실제로는 데이터 유지가 필요한 경우가 많다 

정보가 유지되지 않으면 매번 페이지를 이동할 때마다 로그인을 다시 하거나, 
상품을 선택했는데 구매 페이지에서 선택한 상품의 정보가 없거나 하는 등의 일이 발생할 수 있다. 

따라서 Stateful 경우를 대처하기 위해 쿠키와 세션을 사용한다. 
쿠키와 세션의 차이점은 크게 상태 정보의 저장 위치이다. 
쿠키는 클라이언트에 저장하고 세션은 서버에 저장한다. 

서버와 클라이언트가 통신을 할 때 통신이 연속적으로 이어지지 않고 한 번 통신이 되면 끊어진다. 
따라서 서버는 클라이언트가 누구인지 계속 인증을 해줘야 한다. 하지만 그것은 매우 귀찮고 
번거로운 일이다. 
그런 번거로움을 해결하는 방법이 바로 쿠키와 세션이다. 

쿠키 
HTTP의 일종으로 사용자가 어떠한 웹 사이트를 방문할 경우, 
그 사이트가 사용하고 있는 서버에서 사용자의 컴퓨터에 저장하는 작은 기록 정보 파일이다. 
HTTP에서 클라이언트의 상태 정보를 클라이언트의 PC에 저장하였다가 필요시 정보를 참조하거나 재사용할 수 있다. 

쿠키 특징
1. 이름 , 값, 만료일 , 경로 정보로 구성되어있다. 
2. 클라이언트에 총 300개의 쿠키를 저장할 수 있다. 
3. 하나의 도메인 당 20개의 쿠키를 가질 수 있다. 
4. 하나의 쿠키는 4kb까지 저장 가능하다. 

쿠키의 동작 순서
1. 클라이언트가 페이지를 요청한다. 사용자가 웹사이트에 접근
2. 웹 서버는 쿠키를 생성한다. 
3. 생성한 쿠키에 정보를 담아 HTTP 화면을 돌려줄 때, 같이 클라이언트에게 돌려준다. 
4. 넘겨받은 쿠키는 클라이언트가 가지고 있다가 다시 서버에요청할 때 요청과 함께
5. 쿠키를 전송한다. 
6. 동일 사이트 재방문 시 클라이언트의 PC에 해당 쿠키가 있는경우, 요청 페이지와 
7. 함께 쿠키를 전송한다. 


모듈이란 : 소프트웨어 설계에서 특정 기능을 수행하는 독립적인 요소를 의미한다. 
모듈은 재사용가능하고, 시스템의 다른 부분과는 독립적으로 개발, 테스트, 디버깅이 가능하다. 

DI란 : DI란 의존성 주입을 의미한다. 이것은 객체가 필요로 하는 의존성을 외부에서 
주입하는 디자인 패턴이다. 객체는 자신의 의존성을 생성하지 않고, 외부의 주체가 
제공한다. 

IOC 제어의 역전을 의미한다. IOC는 프로그램의 제어 흐름을 사용자 코드에서 프레임워크로 
옮기는 프로그래밍 원칙이다. 이를 통해 코드의 결합도를 낮추고, 유지보수성 및 
확장성을 높일 수 있다. 

OOP의 2대 원칙 : 일반적으로 OOP의 네 가지 기본 원칙이 있으며, 그 중 두 가지는
캡슐화 와 다형성 일 수 있다. 캡슐화는 객체의 상태를 내부에 숨기고, 공개 메서드를 
통해서만 접근을 제어하는 원칙이다. 다형성은 같은 인터페이스나 기본 클래스를 
상속받은 객체들이 다양한 방식으로 해당 인터페이스나 클래스의 메서드를 구현할 수 있는
원칙입니다. 

사용 예시 
1. 방문사이트에서 로그인 시 "아이디와 비밀번호를 저장하시겠습니까?"
2. 팝업창을 통해 "오늘 이 창을 다시 보지 않기 "체크

세션(Session)
일정 시간 동안 같은 사용자로부터 들어오는 일련의 요구를 하나의 상태로 보고, 그 상태를 
유지시키는 기술이다. 
여기서 일정 시간은 방문자가 웹 브라우저를 통해 웹 서버에 접속한 시점부터 
웹 브라우저를 종료하여 연결을 끝내는 시점을 말한다. 
즉, 방문자가 웹 서버에 접속해 있는 상태를 하나의 단위로 보고 그것을 세션이라고 한다. 

세션 특징
1. 웹 서버에 웹 컨테이너의 상태를 유지하기 위한 정보를 저장한다. 
2. 웹 서버의 저장되는 쿠키(= 세션 쿠키) 
3. 브라우저를 닫거나, 서버에서 세션을 삭제했을 때만 삭제가 되므로, 쿠키보다 비교적 보안이 좋다. 
4. 저장 데이터에 제한이 없다. 
5. 각 클라이언트에 고유 Session ID를 부여한다. Session ID로 클라이언트를 구분해
6. 각 요구에 맞는 서비스를 제공

사용 예시 
화면을 이동해도 로그인이 풀리지 않고, 로그아웃하기 전까지 유지

쿠키와 세션의 차이 
쿠키와 세션은 비슷한 역할을 하며, 동작 원리도 비슷하다. 그 이유는 세션도 결국 
쿠키를 사용하기 때문이다. 
큰 차이점은 사용자으 ㅣ정보가 저장되는 위치이다. 쿠키는 서버의 자원을 전혀 사용하지 
않으며, 세션은 서버의 자원을 사용한다. 
보안 면에서 세션이 더 우수하며, 
쿠키는 클라이언트 로컬에 저장되기 때문에 변질되거나 request에서 스니핑 당할 우려가 
있어서 보안에 취약하지만
세션은 쿠키를 이용해서 Session-id만 저장하고 그것으로 구분하여 서버에서 처리하기
때문에 비교적 보안성이 높다. 
라이프 사이클은 쿠키도 만료기간이 있지만 파일로 저장되기 때문에 브라우저를 종료해도 
정보가 유지될 수 있다. 또한 만료기간을 따로 지정해 쿠키를 삭제할 때까지 유지할 수도 
있다. 
반면에 세션도 만료기간을 정할 수 있지만, 브라우저가 종료되면 만료기간에 상관없이 
삭제된다. 
속도 면에서 쿠키가 더 우수하며, 
쿠키는 쿠키에 정보가 있기 때문에 서버에 요청시 속도가 빠르고 
세션은 정보가 서버에 있기 때문에 처리가 요구되어 비교적 느린 속도를 낸다. 

보통 쿠키와 세션의 차이에 대해서 저장 위치와 보안에 대해서는 잘 알고 있지만
사실 가장 중요한 것은 라이프사이클이다. 

세션을 사용하면 좋은데 왜 쿠키를 사용할까?
세션은 서버의 자원을 사용하기 때문에 서버 자원에 한계가 있어 속도가 느려지 ㄹ수 
있기 때문에 자원관리 차원에서 쿠키와 세션을 적절한 요소 및 기능에 병행 사용하여
서버 자원의 낭비를 방지하며 웹사이트의 속도를 높일 수 있다. 


주제 - 2개 정도의 사이트 정리 제출
각 사이트별 주요 메뉴
어떤 기술이 사용되었는지 ?? ajax, css, js, …
데이터를 어떻게 만들었을까??


오늘의 집

1. 각 사이트별 주요 메뉴
커뮤니티 / 쇼핑 / 이사/시공/생활

2. 어떤 기술이 사용되었는지
-  <meta name="csrf-param" content="authenticity_token"/>
   <meta name="csrf-token" content="GxSBEglpKB+HPEQPzwKxPedeomBMdSgfOyJEKPH33ow3Jy0rcs/vAHvj2IfdfkooC11ITzOLH1Cibybejo+9Vw=="/>
    태그를 통해 사이트 간 요청 위조 공격 보호 기술
-  <link rel="alternate" href="android-app://net.bucketplace/http/ohou.se/deep"/>
   안드로이드 앱과의 딥링크 설정기술

3. 데이터를 어떻게 만들었을까

- 카카오 로그인 api를 이용해 카카오 이메일과 이름을 받아와 회원생성해주기
- ajax나 WebSocket연결을 사용하여 실시간 인기검색어 띄우기

쿠키와 세션 그리고 캐시(Cache)?
캐시는 웹 페이지 요소를 저장하기 위한 임시 저장소이고, 
쿠키/세션은 정보를 저장하기 위해 사용된다. 

캐시는 웹 페이지를 빠르게 렌더링 할 수 있도록 도와주고, 
쿠키/세션은 사용자의 인증을 도와준다.
- 캐시는 이미지, 비디오, 오디오, css, js 파일 등 데이터나 값을 미리 복사해 놓는
- 리소스 파일들의 임시 저장소이다.
저장공간이 작고 비용이 비싼 대신 빠른 성능을 제고앟ㄴ다. 

같은 웹 페이지에 접속할 때 사용자의 PC에서 로드하므로 서버를 거치지 않아도 된다. 
이전에 사용된 데이터가 다시 사용될 가능성이 많으면 캐시 서버에 있는 데이터를 사용한다. 
그래서 다시 사용될 확률이 있는 데이터들이 빠르게 접근할 수 있어진다. 
캐시 히트: 캐시를 사용할 수 있는 경우 
캐시 미스 : 캐시를 사용할 수 없는 경우

www.naver.com에 접속할 때 생기는 과정에 대해 설명해주세요(웹 동작 방식 이해)

1. 사용자가 웹 브라우저에 www.naver.com을 입력한다.
2. 사용자가 입력한 URL 정보를 DNS 서버에 요청한다.
3. DNS 서버에서 www.naver.com의 IP 주소를 찾아 사용자에게 응답한다.
4. 사용자가 입력한 URL 정보를 IP 주소로 변환하여 웹 서버에 요청한다.
5. 웹 서버는 사용자의 요청을 받아 사용자에게 응답한다.
6. 사용자는 웹 서버로부터 받은 응답을 웹 브라우저에 출력한다.
7. 웹 브라우저는 사용자에게 받은 응답을 출력한다.
8. 웹 브라우저는 웹 페이지를 렌더링한다.

String sql = "insert into member values (?,?,?,?)";

String sql = "select * from member where id = ? and pw = ?";










































