### 11_10

Having과 where의 차이를 설명해주세요
having은 그룹을 필터링 하는데 사용되고, where은 개별 행을 필터링하는데 사용됩니다. 

집계함수 (Count, sum, AVG, MAX, MIN)은 having 절과 함께 사용할 수 있으나, 
where 절은 사용할 수 없다. 
집계함수를 사용할 수 있는 group by 절보다 where 절이 먼저 수행

having은 그룹화 또는 집계가 발생한 후 필터링하는데 사용되고
where은 그룹화 또는 집계가 발생하기 전에 필터링하는데 사용된다. 

JOIN에서 ON과 WHERE의 차이를 설명해주세요
ON이 WHERE보다 먼저 실행되어 JOIN을 하기 전에 필터링을 하고 
WHERE은 JOIN을 한 후에 필터링을 한다. (JOIN을 한 결과에서 WHERE조건절로 필터링이 이뤄진다)

해시 테이블과 시간복잡도에 대해 설명해주세요
해시 테이블은 (Key, Value)로 데이터를 저장하는 자료구조 중 하나로 빠르게 데이터를
검색할 수 있는 자료구조이다. 
빠른 검색 속도를 제공하는 이유는 내부적으로 배열을 사용하여 데이터를 저장하기 떄문이다. 
각 key값은 해시함수에 의해 고유한 index를 가지게 되어 바로 접근할 수 있으므로 
평균 O(1)의 시간 복잡도로 데이터를 조회한다. 하지만 index값이 충돌이 
발생한 경우 Chaining에 연결된 리스트들까지 검색해야 하므로 
O(N)까지 증가할 수 있다. 

Hash Map 과 Hash Table의 차이점에 대해 설명해주세요
동기화 지원 여부와 null 값 허용 여부의 차이가 있습니다
해시 테이블 
병렬 처리를 할 때 (동기화를 고려해야 하는 상황) Thread-safe 하다
null 값을 허용하지 않는다.

해시 맵
병렬처리를 하지 않을 때 (동기화를 고려하지 않아도 되는 상황) Thread-safe 하지 않다
Null 값을 허용한다. 

BTS(Binary Search Tree)와 Binary Tree에 대해 설명해주세요

이진트리는 자식 노드가 최대 두 개인 노드들로 구성된 트리이고, 
이진 탐색 트리는 이진 탐색과 연결 리스트를 결합한 자료구조입니다. 
이진탐색의 효율적인 탐색 능력을 유지하면서, 빈번한 자료 입력과 삭제가 가능하다는 
장점이 있다. 

이진탐색트리는 왼쪽 트리의 모든 값은 반드시 부모 노드보다 작아야 하고, 오른쪽 트리의 값은
부모 노드보다 커야 하는 특징이 있습니다. 
이진탐색트리는 왼쪽 트리의 모든 값은 반드시 부모 노드보다 작아야 하고, 오른쪽 트리의
값은 부모 노드보다 커야하는 특징이 있습니다. 

이진 탐색 트리의 탐색 연산은 트리의 높이에 영향을 받아 높이가 h일 때 시간복잡도는
O(h)이며, 
트리의 균형이 한쪽으로 치우쳐진 경우 worst case가 되고 O(n)의 시간 복잡도를 가진다. 
이런 worst case를 막기 위해 나온 기법이 Red-Block Tree이다. 

RBT에 대해 설명해주세요
RBT는 BST를 기반으로 하는 트리 형식 자료구조이며, RBT는 BST의 삽입, 삭제 
연산 과정에서 발생할 수 있는 문제점을 해결하기 위해 만들었다. 
BST를 기반으로 하기 때문에 BST의 특징을 모두 갖는다. 

노드의 Child가 없을 경우 Child를 가리키는 포인터는 NIL 값을 저장한다. 
이러한 NIL들을 Leaf node로 간주한다. 

모든 노드를 빨간색 또는 검은색으로 색칠하며, 연결된 노드들은 색이 중복되지 않는다. 

동적 계획법(DP, Dynamic Programming)에 대해 설명해주세요
주어진 문제를 풀기 위해, 문제를 여러 개의 하위 문제로 나누어 푸는 방법을 말한다. 
동적 계획법에서는 어떤 부분 문제가 다른 문제들을 해결하는데 사용될 수 있어, 
답으 ㄹ여러버 ㄴ계산하는 대신 한번만 계산하고 그 결과를 재활용하는 
메모이제이션 기법으로 속도를 향상시킬 수 있다. 

동적 계획법이 갖는 2가지 조건은 무엇인가요?
1. 중복되는 부분 문제
중복되는 부분 문제는 나눠진 부분 문제가 중복되는 경우로, 메모이제이션 기법을 사용해 
2. 중복 계산을 없앱니다. 
최적 부분 구조 
3. 최적 부분 구졸르 가진다는 것은 전체 문제의 최적해가 부분 문제의 
4. 최적해들로써 구성된다는 것이다. 

버블 정렬 에 대해 설명해주세요

버블 정렬은 서로 인접한 두 원소를 비교하여 정렬하는 알고리즘입니다. 
0번 인덱스부터 n-1번 인덱스까지 n번까지의 모든 인덱스를 비교하며 정렬합니다. 
시간복잡도는 O(n^2)이며, 최선의 경우 O(n)의 시간복잡도를 가집니다.

선택 정렬에 대해 설명해주세요
선택 정렬은 첫 번째 값을 두번째 부터 마지막 값까지 차례대로 비교하여 최솟값을 찾아
첫 번째에 놓고, 두 번째 값을 세 번째 부터 마지막 값 까지 비교하여 최솟값을 찾아 
두 번째 위치에 놓는 과정을 반복하며 정렬하는 알고리즘입니다. 
시간복잡도는 O(n^2)이며, 최선의 경우 O(n^2)의 시간복잡도를 가집니다.

삽입 정렬
삽입 정렬은 두 번째 값부터 시작해 그 앞에 존재하는 원소들과 비교하여
삽입할 위치를 찾아 삽입하는 정렬 알고리즘입니다. 
평균 시간복잡도는 O(n^2)이며, 최선의 경우 O(n)의 시간복잡도를 가집니다.

힙 정렬에 대해 설명해주세요
힙 정렬은 주어진 데이터를 힙 자료구조로 만들어 최댓값 또는 최솟값부터 하나씩 꺼내서
정렬하는 알고리즘이다. 
힙 정렬이 가장 유용한 경우는 전체를 정렬하는 것이 아니라 가장 큰 값 몇개만을 필요로
하는 경우이다. 시간 복잡도는 O(nlogn)입니다. 

병합 정렬에 대해 설명해주세요
병합 정렬은 주어진 배열을 크기가 1인 배열로 분할하고 합병하면서 정렬을 진행하는 분할/정복
알고리즘입니다. 시간 복잡도는 O(nlogn)입니다. 

퀵 정렬에 대해 설명해주세요
퀵 정렬은 빠른 속도를 자랑하는 분할 정복 알고리즘 중 하나로 피봇을 설정하고 
피봇보다 큰 값과 작은 값으로 분할하여 정렬 합니다. 
병합정렬과 달리 리스트를 비 균등하게 분할합니다. 
시간복잡도는 O(nlogn)이며, worst case경우 O(n^2)까지 나빠질 수 있습니다. 

허프만 코딩에 대해 설명해주세요
허프만 코딩은 문자의 빈도 수를 가지고 압축하는 과정을 말하며 접두부 코드와 최적 코드를 사용합니다. 
접두부 코드 : 각 문자에 부여된 이진 코드가 다른 이진 코드의 접두부가 되지 않는 코드 
최적 코드 : 인코딩된 메시지의 길이가 가장 짧은 코드 

재귀 알고리즘에 대해 설명해주세요
재귀 알고리즘이란 함수 내부에서 함수가 자기 자신을 또 다시 호출하여 문제를 해결하는
알고리즘입니다. 자기자신을 계속해서 호출하여 끝없이 반복되게 하므로 
반복을 중단할 조건이 반드시 필요합니다. 

피보나치 수열의 N번째 값을 구하는 메소드에 대해 각각 재귀 와 반복문으로 손코딩 해주세요

private static int recursiveFibonacci(int index){
if( index <= 2) {
return 1;
return recursiveFibonacci(index - 1) + recursiveFibonacci(index - 2);
}

private static int loopFibonacci(int index){
int answer = 1;
int before = 1;
int temp = 0;
for(int i = 2; i < index; i++){
temp = answer;
answer += before;
before = temp;
}
return answer;
}

팩토리얼의 N번째 값을 구하는 메소드에 대해 각각 재귀와 반복문으로 손코딩 해주세요

private static int 

알고리즘을 생각하세요
sorting 
divide and conquer
dp / memoization
greediness
recursion
algoriths assoicated with data structures

데이터 구조를 생각하시오
Array
stack/queue
hashset/ hashmap/hasdhtable/dictionary
tree/binary tree
heap
graph












































