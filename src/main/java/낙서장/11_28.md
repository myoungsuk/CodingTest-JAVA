### 11_28

jpa cascade란?
캐스캐이드 옵션을 사용하면 부모 엔티티를 저장할 때 자식 엔티티도 함께 저장할 수 있다.
```java
@OneToMany(mappedBy = "parent", cascade = CascadeType.ALL)
private List<Child> childList = new ArrayList<>();
```

jpa cascade의 종류
- ALL : 모두 적용
- PERSIST : 영속
- REMOVE : 삭제
- MERGE : 병합
- REFRESH : REFRESH
- DETACH : DETACH
- SAVE_UPDATE : SAVE_UPDATE
- REPLICATE : REPLICATE
- LOCK : LOCK
- EVICT : EVICT
- DELETE : DELETE
- REMOVE : REMOVE

void bookCascadeTest() {
Book book = new Book();
객체 하나 생성 하고
book.setName("JPA ORM");

bookRepository.save(book);

캐스케이드란 부모 엔티티를 저장할 때 자식 엔티티도 함께 저장할 수 있다.
bookRepository.save(book);
}

출판사에 대한 정보를 추가해보도로갛자 
Publisher publisher = new Publisher();
publisher.setName("패스트캠퍼스");

엔티티간에 연관 관계를 세터를 통해 마들어준다. 
book.setPublisher(publisher);
bookRepository.save(book);

이렇게 하면 book과 publisher가 연관관계가 생긴다.
books의 리스트타입 
publisher.setBooks(Arrays.asList(book));
publisher.getBooks().add(book);
publisherRepository.save(publisher);

잘 들어갔는지 확을 위해서 sout bookRepository.findAll

자바에서 제공하는 publisher가 가지고있는 books에 대한 정보도 같이 바뀌게 된다. 
가독성있는 코드가 트랜드이기 떄문에 
setter를 사용하는게 더 직관적이다. 
public void addBook(Book book) {
this.books.add(book);
}
본인의 booksㅇ

위에 게터를 사용해서 하는것보다 publisher.addBook(book); 이렇게 하는게 더 직관적이다.

이렇게 하고 테스트를 해보면 오류가 발생한다. 
mysql이 로컬에서 실행되지 않으면 오류가 날 수 있다. 스프링에서 

orm에서 jpa와 
이런식으로 dialect 설정을 하면 어떻게 하나 이렇게 접근할수도 있는데 

스프링이나 스프링부트라는것도 굉장히 단순화 해서 사용할 수 있게 했다. 
방금전에 발생했던 오류에 대해서 많이 겪어보고 어떻게 하면 빠르게 처리할 수 있을지 jpa에 전문화되는 큰
도움이 될 것이다. 특히 jpa라던지 db관련 오류둘은 진짜 오류에 대한 메시지 보다는 약간 둘러둘러 
말하는 경우가 있다. 
nosession 이라는 것도 알면 쉽지만 왜 오류가 났는지 모르기때문에 오류에 대한 공부를 많이 하도록 하자

우리가 첫 시간에 배웠던 orm을 떠올려 보면 jpa는 자바 쿼리를 sql로 번역해주는 기능이다 
여기 보면 자바 쿼리랑 sql이 섞여있는 느낌이 든다. 
save를 중간중간 처리하는 모습이 보이ㅡㄴ데 
save를 해서 영속성 관리를 해주지 않고 set을 해서 만들고 

set을 해주고 나중에 setter를 통해서 진행하고 save 처리를 나중에 하는게 더 좋다. 
근데 캐스케이드를 사용하면 save 메서드도 필요없다.

영속성 전이를 통해서 
북과 퍼블리셔의 연관관계를 생성해주고 bookRepository.save(book); 이렇게 하면
엔티티의 레퍼런스가 db에 저장되지 않고 자바 객체이기 때문에 저장할 수 없다는 의미이다. 
연관관계를 맺었는데 book이나 publisher가 영속성 관리가 되지 않는데 
연관관계를 맺을려 해서 그런 것이다. 
그래서 앞에 만든 로직에는 실제 db에 일단 저장을 하고 영속성을 맺어주게 된다. 
이렇게 처리를 해주는데 save라는 메서드를 제거했기 때문에 cascade 옵션을 book쪽에 걸어주게 된다. 

@ManyToOne(cascade = CascadeType.PERSIST)

persist라는게 일어날 때 bookdlfksms dpsxlxldp wjrdydehlf Eo 
연관성이 있는 publisher도 persist전이가 일어나게 된다. 
퍼플리셔 연관관계를 

Book book1 = bookRepository.findById(1L).get();를 통해서 
book1.getPublisher().setName("슬로우캠퍼스");

bookRepository.save(book1); 이렇게 하고 결과값을 보면 슬로우캠퍼스라고 변경을 했는ㄷ ㅔ
적용되지 않은걸 볼 수 있다. 

머지에 대한이벤트가 발생한다. 그런데 우리가 cascade에서 persist에 대해서만 하겠다
라고 처리를 하면 merge에 대해서는 영속성 전이가 일어나지 않는 것이다. 
publisher는 별도로 merge를 처리해야되게 되는것이다. 
merge에 대해서도 cascade추가 하도록 처리를 해보도록 하자 .
캐스캐이드는 배열 형태로 받게 되어있는데 persist와 merge에 대해서 영속성 전이를 이루겠다 라는 듯이다. 

사실 퍼블리셔에 대해서는 호출한 적도 없고 북 엔티티에서만 처리했는데
북 엔티티에 대해서 연관 관계에 있는 퍼블리셔를 처리하게 만든 것이다. 

배열로 주기도 하지만 줄여서 CascadeType.ALL 로 모든 전이를 처리할 수도 있다.
영속성 전이라는 옵션을 어떤식으로 활용할 수 있는지 알아봣다. 

Book book2 = bookRepository.findById(1L).get();
bookRepository.delete(book2);

고아제거속성 알아보기 
고아제거는 부모 엔티티를 제거할 때 자식 엔티티도 함께 제거하는 옵션이다.
```java
@OneToMany(mappedBy = "parent", cascade = CascadeType.ALL, orphanRemoval = true)
private List<Child> childList = new ArrayList<>();
```

book에 대한 조회는 없는 것으로 나오지만 publisher에 대한 조회는 남아있는 것을 볼 수 있다.
book이라는 엔티티는 삭제 처리가 됬기 때문에 없지만 
퍼블리셔는 삭제를 하지 않았기 때문에 없는 것으로 나온다. 
만약 퍼블리셔를 함께 삭제하기 위해서는 어떻게 해야될까 
publisherRepository.delete(book2.getPublisher()); 이렇게 하면 삭제가 된다.

CascadeType.REMOVE를 추가해주면 book을 삭제할 때 publisher도 같이 삭제가 된다.
@OneToMany(mappedBy = "parent", cascade = {CascadeType.PERSIST, CascadeType.REMOVE}, orphanRemoval = true)

하나의 퍼블리셔가 여러개의 연관관계를 맺고있으면 어떡하냐 
book1이 사라지면 기존에 남아있는 book들에 대해서는 어떠헥 처리가 될지 알아보자 
우리가 처음에 사용했던 datasql을 사용해서 데이터를 넣어보자

insert into publisher(id, name) values(1, '패스트캠퍼스');

insert into book(id, name, publisher_id) values(1, 'JPA ORM', 1);

역 컴마를 사용했는데 컬럼의 이름들을 정리할 때 사용한다. 사실 없는 경우도 상관 없는데 이름이 
sql에서 금지하는 단어라던가 하면 사용을 해야된다.백틱
문자열을 의미하는 따옴표와는 다르다.

@Test
void bookRemoveCascadeTest() {
데이터가 잘 들어갔는지 확인하기 위해서 bookRepository.findAll();을 해보면
publisherRepository.findAll();을 해보면 
}

연관관계가 tostring에서는 안나온다. 
book1.getPublisher().getBooks().forEach(System.out::println); 이렇게 하면
나온다. 

book.getPublisher().getBooks().remove(book); 이렇게 하면
createAtrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrr

우리가 사전에 만들었던 리스너라던지 ㅇ마이 엔티티 리스너에 어디터블을 구현했다. 
하지만 널로 들어있다. data.sql이라는 것은 단순히 쿼리를 실행시키기만 한다. 
우리가 사전에 만들었던 리스너는 타지 않아서 created updatedat이 없는 것이다. 
그래서 이런 경우에는 어떻게 해야될까 

우리가 bookRepository.deleteById(1L)
cascade는 상위 객체가 삭제되면 하위 객체도 삭제되는 것이다. 하지만 연관관계가 끊어질때는
removce 이벤트가 발생하지 않는다.
orphanRemoval = true를 추가해주면 연관관계가 끊어질 때 remove 이벤트가 발생한다.
@OneToMany(mappedBy = "parent", cascade = CascadeType.ALL, orphanRemoval = true)

마지막으로 삭제 관련해서 cascadeRemoval과 orphanRemoval 차이점에 대해서 알아보자
지금 ㅇ

딜리트 쿼리를 던지면 3번 아이디값이 없어야되는데 3번 아이디 값이 있는 것이다. 

@Test
void softDelete() { 
bookRepository.findAll().forEach(System.out::println);
}

이렇게 하면 삭제가 되지 않은 것을 볼 수 있다.
3번 아이디가 있는데 왜 삭제가 안되는 것일까
deleteById를 하면 delete 쿼리가 나가는데
delete 쿼리가 나가면서 deleteAt이라는 컬럼에 현재 시간이 들어가게 된다.
그래서 삭제가 되지 않는 것이다.

List<Book> findByCategoryIsNull();

데이터베이스에는 값이 존재하지만 로직상에서는 출력되지 않도록 flag값 처리를 하면서
@Where(clause = "deleted = false") 이렇게 처리를 해준다.

@Where(clause = "deleted = false")이란 deleted가 false인 것만 출력하겠다는 의미이다.

쿼리 메서드의 이름이 너무 길어지면 어떻게 해야될까
@Query("select b from Book b where b.deleted = false")
List<Book> findBooksCustom();

쿼리 메소드의 단점을 살펴보기 위해서 일부러 긴 메소드를 만들업 보겠다. 
List<Book> findByCategoryIsNullAndNameEqualsAndCreatedAtGreaterThanEqualAndUpdatedAtGreaterThanEqual(String name, LocalDateTime createdAt, LocalDateTime updatedAt);
bookRepository.findByCategoryIsNullAndNameEqualsAndCreatedAtGreaterThanEqualAndUpdatedAtGreaterThanEqual("JPA ORM", LocalDateTime.now().minusDays(1L), LocalDateTime.now().minusDays(1L));
"select b from Book b where b.category is null and b.name = ?1 and b.createdAt >= ?2 and b.updatedAt >= ?3"

이렇게 하면 쿼리 메소드의 단점이 무엇인지 알 수 있다.
쿼리 메소드의 단점은 너무 길어지면 어떻게 해야될까
@Query("select b from Book b where b.category is null and b.name = ?1 and b.createdAt >= ?2 and b.updatedAt >= ?3")
List<Book> findByNameRecently(String name, LocalDateTime createdAt, LocalDateTime updatedAt);

단순히 코드상으로는 create_at, update_at now() now() 이것보다는 jpa의 속성을 활용해서 수정해보겟다. 

baseEntity에 들어가서 @Column(nullable = false, updatable = false) 이렇게 처리를 해준다.
@Column(nullable = false)
실제로 테스트를 시켰을때 오류가 발생한다.
deleted 
이렇게 고치게 되면 data.sql 을 사실 publisher 여기서 문제가 될 것이다. 

@Column(columnDefinition = "datetime(6) default now(6)", nullable = false, updatable = false)
해당 컬럼에 디폴트 값을 주게 되면 데이터엔티티나 오딭팅 리스너나 동일하게 시가능ㄹ 가지게 된다. 

column definition을 지정하지 않았을땐 null이 나오고  null이 아닌 경우에는 해당 컬럼 definition을
가져오게 되어있다. 

null 인경우에 이후에 넣기 떄문에 null이 아니면 안넣는다. 



































