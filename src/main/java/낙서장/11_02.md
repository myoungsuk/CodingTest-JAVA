### 11_02

비선형자료구조- 그래프 - 2

인접 행렬을 이용한 그래프 구현

class MyGraphMatrix {
그래프는 강의때 배운 그

vertices;
int[][] adjMat;
eleCn;

public MyGraphMAtrix(){
생성자 중에 사이즈가 들어요면
인접행렬도 n바이 n만큼 만들어준다. 

this.vertices = new char[size];
this.adjMat = new int[size][size];
this.eleCnt = 0;
}

public boolean isFull() {
return this.eleCnt == this.vertices.length;
}

public void addVertex(char vertex) {
if (isFull()) {
System.out.println("그래프가 꽉 찼습니다.");
return;
}

그래프가 꽉차있는지 확인하고 ㄱ꽉차있지 않으면 
엘리멘트를 하나 증가시켜주고 데이터를 넣어준다. 

public void addEdge(int x, int y) {
this.adjMat[x][y] = 1;
this.adjMat[y][x] = 1;
}
}

public void addDirectedEdge(int x, int y) {
this.adjMat[x][y] = 1;
}
무방향이니깐 양방향을 연결해주는 메소드를 사용할거고 
딜리트쪽도 만들어준다하면
각각의 데이터들을 0으로 바꿔주면 된다. 

public void deleteDirectedEdge(int x, int y) {
this.adjMat[x][y] = 0;
}

public void printAdjacentMatrix() {
sout    
for (char item : this.vertices) {
System.out.print(item + " ");
}
System.out.println();

for(int i = 0; i < this.eleCnt; i++) { {
for(int j = 0; j < this.elCnt; j++) {


그래프를 응용 문제를 풀거면 기본 그래프는 구성을 해야되고 
처음 그래프를 구성하는것부터 막힐때가 있다. 
해당 간선들에 대한 정보를 업데이트 하는걸 잘 익히도록 하자 

알고리즘 개념에 대한 이해와 
좋은 알고리즘을 구현하겠다는 의지

명확성, 유한성, 효율성 

가장 큰 구간의 합을 구하기 위해서 분할 정복을 써야된다. 

별도로 public static int divideSubArray

if(left == right) {
return nums[left];

int mid = (left + right) / 2;
int maxLeft = divideSubArray(nums, left, mid);
int maxRight = divideSubArray(nums, mid + 1, right);

return 0;


public static int getMaxSubArray(int[] nums, int left, int mid, int rihgt) {

int sumLeft = 0;
int maxLeft = Integer.MIN_VALUE;

public static Node divideList(Node[] lists, int left, int right) {
if(left == right) {
return lists[left]; // 탈출조건

int mid = (left + right) / 2;
Node leftNode = divideList(lists, left, mid);
Node rightNode = divideList(lists, mid + 1, right);


Node(int val) {
this.val = val;
this.next = null;
}

return mergeList(l1, l2);

public static Node mergeList(Node l1, Node l2) {
if(l1 == null) {
return l2;
}

if(l2 == null) {
return l1;
}

if(l1.val < l2.val) {
l1.next = mergeList(l1.next, l2);
return l1;
} else {
l2.next = mergeList(l1, l2.next);

while (l1 != null && l2 != null) {
if(l1.val < l2.val) {
































