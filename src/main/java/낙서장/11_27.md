### 11_27

진격의 거인

주술회전

소드아트 온라인

죠죠의 기묘한 모험

어나더

스쿨데이즈

쓰르라미 울적에

격투맨 바키

노 건즈 라이프

종말의 발키리

닥터 스톤

괴물사변

도쿄 리벤져스

도쿄 구울

지옥락

노블레스

캐슬바니아

러브 데스 로봇

스프리건

도타: 용의 피

바스타드: 암흑의 파괴신

베르세르크

도로헤도로

사이코패스

카우보이 비밥

아카메가 벤다!

도로헤도로

살육의 천사

약속의 네버랜드

노리가미

아인

청의 엑소시스트

오버로드

아프로 사무라이

고블린 슬레이어

페이트 시리즈

소드가이 : 애니메이션

가이버 시리즈

야스케

B: 더 비기닝

일곱개의 대죄

블러드 오브 제우스

트레세: 도시의 수호자

데빌맨 시리즈

여섯 개의 주먹

간츠 시리즈

드래곤즈 도그마

파이어 펀치

원펀맨

가시나무왕

persistance context : 영속성 컨텍스트
영속성 컨테이너가 관리하고 있는 내용이다 라는 뜻
persistance 즉 영속화 라는 의미는 사라지지않고 지속 가능하다는 뜻이다. 
영속성 컨텍스트는 엔티티를 영구 저장하는 환경이다.
영속성 컨텍스트는 논리적인 개념이다.
영속성 컨텍스트는 엔티티 매니저를 생성할 때 하나 만들어진다.
영속성 컨텍스트는 엔티티 매니저를 통해서 접근한다.
엔티티 매니저는 영속성 컨텍스트에 접근할 수 있는 유일한 방법이다.
영속성 컨텍스트는 트랜잭션과 생명주기가 같다.
영속성 컨텍스트는 엔티티를 저장하는 가상의 데이터베이스라고 생각하면 된다.
영속성 컨텍스트는 내부에 캐시를 가지고 있다.
영속성 컨텍스트는 엔티티를 식별자 값으로 구분한다.
영속성 컨텍스트는 트랜잭션을 지원하는 쓰기 지연

영속성 컨텍스트는 persistance.xml이라는 파일로 설정해서 쓴다. 
META-INF/persistance.xml
persistence-unit name="hello"
persistence-unit name="hello" transaction-type="RESOURCE_LOCAL"
persistence-unit name="hello" transaction-type="JTA"
persistence-unit name="hello" transaction-type="JTA"

영속성 컨텍스트를 설정하거나 신경쓰지않아도 할 수 있었다. 
그게 어떻게 된 거냐면 스프링 부트 스타터 데이터 jpa 가 스프링부트가 persistance 에 대한 설정을
모두 처리해줬기 때문에 쉽게 사용할 수 있었던 것이다. 

영속성 컨텍스트는 엔티티를 식별자 값으로 구분한다
영속성 컨텍스트는 내부에 캐시를 가지고 있다.
영속성 컨텍스트는 엔티티를 식별자 값으로 구분한다.
영속성 컨텍스트는 트랜잭션을 지원하는 쓰기 지연 기능을 제공한다.
영속성 컨텍스트는 변경 감지 기능을 제공한다.
영속성 컨텍스트는 지연 로딩 기능을 제공한다.

serverTimezone=Asia/Seoul

datasource:
    url: jdbc:mysql://localhost:3306/jpashop?serverTimezone=Asia/Seoul
    username: root
    password: 1234
    driver-class-name: com.mysql.cj.jdbc.Driver

Test쪽 context 돌려보자 driver class 문제 생김 
build.gradle에 runtimeOnly 'mysql:mysql-connector-java' 추가해주자
실제로 context가 정상적으로 동작 하는데 using dialect: MySQL5Dialect 이라는 문구가 뜬다.

Using dialect H2Dialect 이라는 문구가 뜬다.
Dialect 라는 뜻은 방언이라고 해석이 되는데 Entity나 Re

쿼리를 알아서 맞춰주는게 dialect 의 일이다 . h2의 dialect 를 mysql dialect로 변경해준다. 

AuthorRepositoryTest 해봤는데 
No databaseSelected 처리가 나온다. 
book_manager

generated-ddl : true
hiberante:ddl-auto : create-drop

기존에는 h2 디비를 사용해서 기본값을 사용하지 않았는데 mysql을 쓰면서 generated-ddl : true
hiberante:ddl-auto : create-drop 을 사용하면서 기본값을 사용하게 되었다.

상용 db라서 generated-ddl : true 을 옵션으로 켜줘야되는것이다. 

ddl-auto : create-drop 은 테이블을 생성하고 사용한 다음에 drop을 해버리는 것이다.

create는 persistance에서 drop하고 띄우는데 
create-drop은 종료할때 drop하는 차이가 있다. 
업데이트를 하면 실제 클래스와 엔티티 부분을 반영해 변경되는 부분만 바뀌고 drop안함

initialization-mode: always
임베드 db이고 데이타 나 스키마 sql 파일이 resources 폴더 밑에 존재한다면 자동으로 로드시켜줬기 때문에 
우리가 기존 로직에선 별다른 설정 없이 사용할 수 있었다. 
mysql 환경에서 사용하면 임베디드 db의 경우에만 쓴다는거고 always는 항상 실행한다는 뜻이다.

데이터 초기화를 진행하지 않는다고 하면 운영 배포를 할 때는 데이터의 초기화를 하면 안되니깐 
만약에 initialization-mode로 always로 하고 스키마 파일이 있고 
ddl-auto가 create-drop이면 스키마 파일을 먼저 실행하고 그 다음에 create-drop을 실행한다.
그래서 스키마 파일을 실행하고 데이터를 넣어주면 데이터가 들어가 있는 상태로 실행이 된다.

스키마 sql 파일이 더욱 우선적으로 식행되기때문에 이니셜라이제이션 모드를 always로 해줘야한다.
우리는 schema-sql 
이 있으면 ddl auto는 무시된다고 한다. 

prePersistTest(); 
쿼리에 유니크 리졸트가 와야되는데 너무 많이 왔다 라고 한다. 
사실 이런 경우는 지금 우리가 테스트를 

클래스 상단에 @Transactional 어노테이션을 처리하면 롤백해주는 일을 해준다. 
Helloworld 메서드는 JPA metamodel must not be empty

helloworld 테스트가 webmvctest 슬라이스 테스트라고하는데 전체 테스틀르 하지않고 
웹 컨트롤러에서만 진행하기 때문에 JPA를 사용하는 부분은 빈으로 등록이 되지 않는다.
그래서 JPA를 사용하는 부분을 등록해줘야한다.
@MockBean(JpaMetaModelMappingContext.class) 를 추가해주면 된다.
헬로 월드 컨트롤러에서는 jpa가 필요가 없기 때문에 로딩을 할 수 없었던 건데 
목빈으로 해서 마치 있는 것 처럼 해주면서 해결할 수 있다. 

Book Manager에 있는 applcation EnableJpaAuditing 별도의 클래스로 생성해서 
JpaConfiguration 별도의 bean에서 로딩시켜주는 것이다. 

@Autowired
private WebApplicationContext context;

private MockMvc mockMvc;

@BeforeEach
void before() {
mockMvc = MockMvcBuilders
            .webAppContextSetup(context)
            .apply(springSecurity())
            .build();
}

자동으로 만들어줬던 mockmvc를 우리가 직접 해본 것이다. 

처리 방법에 있어서는 두가지가 있다.
실제로는 로딩이 된 줄 알았는데 Mockbean이라서 그런 걸 수도 있다 .
조금은 더 보편적인 방법을 사용하는게 좋을 수도 있다. 

crud테스트에서 생기는 not-null 문제 
@OneToOne(optional = false)

실제로는 one to one 기능이니 setbook(givenbook())으로 릴레이션 걸어주면 된다. 

crud테스트 2의 경우에는 실제로 단독으로 실행시키면 아무런 문제가 없는 테스트이다. 
서로 테스트가 영향을 주는 것 같다. 
bookRepository가 1번 아이디의 정보를가져왔는데 nulㅣ이라고 하는 것이다. 
h2 db에서는 시퀀스라고 사용하는데 GenerationType.IDENTITY를 사용하면
시퀀스를 사용하지 않고 자동으로 생성해준다.

@OneToOne(mappedBy = "book", cascade = CascadeType.ALL)
private BookReviewInfo bookReviewInfo;

book을 우리가 givenBook이라고해서 사용했다. save하면 auto increment가 되면서 id가 생성이 된다.
실제로 여기서 만든 값이 1이 되었었는데 
계속 증가해서 
1이 아니라 7이 되었다.

영속성 컨텍스트에서 가장 중요한 역할을 하고있는 엔티티매니저와 엔티티들을 관리하는 영속성 컨텍스트가 있다.
알아보도록 하자 

지난시간에는 기본적인 영속성 컨텍스트에 대해서 알아보았다. 사실 영속성 컨텍스트는 일종의 
jpa 컨테이너 안에서 동작하는 엔티티의 맥락을 관리하는걸 영속성 컨텍스트라고 한다. 
컨텍스트 안에서 일반적으로 엔티티는 생성되고 지워지고 조회된다. 그런 컨텍스트 안에서 가장 중요한 역할을
하는것이 엔티티 매니저이다. 
엔티티 매니저의 역할으 ㄹ알아보고 처리하느 ㄴ과정에서 캐시를 사용하는데 어떤식으로 활용하는지 살펴보면서 
영속성 컨텍스트에 대해서 알아보도록 하겠다. 

엔티티 매니저 역시 jpa에서 정의하고 있는 일종의 인터페이스이다. 

@SpringBootTest
public class EntityManagerTest {
    
        @Autowired
        private EntityManager entityManager;
    
        @Test
        void entityManagerTest() {
            System.out.println(entityManager.createQuery("select u from User u").getResultList();
        }
    }

유저 레포지터리에 findAll이라는 쿼리를 동작시키는 것이다. 
기존에 우리가 사용했던 쿼리 메소드 심플 jpa는 직접적으로 엔티티매니저를 사용하지 않아도 되도록
한번더 래핑을 해서 스프링에서 제공하는 걸 알 수 있다. 

스프링 데이터 jpa에서 제공하느 ㄴ기능이 아닌걸 사용하면 별도로 커스터마이징을 하면
entity Manager를 통해서 처리하면 된다. 

hibernate에서 엔티티 매니저는 세션이라고 부른다. 
세션은 영속성 컨텍스트를 관리하는 역할을 한다.

영속성 컨텍스트에서 영속성 매니저는 엔티티를 관리하느 ㄴ엔티티매니저가 있다. 
엔티티 매니저는 영속성 컨텍스트를 관리하는 세션과 같은 역할을 한다.

find를 통해서 캐시 역할을 하는걸 한번 보도록 해보자 

@Test
void cacheFindTest() {
    User user = userRepository.findById(1L).get();
    user.setName("martin2");
    userRepository.save(user);
    user.setEmail("martin2@gmail.com");

이렇게 해서 이메일을 조건으로 갖는 쿼리가 세번 호출된다.

cacheFindTest() {
findById(1L).get();
셀렉트 쿼리가 이렇게 실행된다. 이렇게 findById를 통해 가져오면 
셀렉트 쿼리가 한번 두번 세번 실행되는데 이렇게 되는 이유는
처음에는 영속성 컨텍스트에 캐시가 없기 때문에 셀렉트 쿼리를 실행하고
두번째는 영속성 컨텍스트에 캐시가 있기 때문에 셀렉트 쿼리를 실행하지 않고
영속성 컨텍스트에 있는 캐시를 가져오기 때문에 셀렉트 쿼리가 실행되지 않는다.

@Transactional 어노테이션을 넣으면 
조회시에 영속성 컨텍스트내에 존재하는 엔티티 케시에서 직접 처리한 것을 알 수 있다 .
진짜 디비에서 하지 않고 영속성 컨텍스트 내에서 자동으로 캐시 처리하는 것을 
jpa의 일차 캐시라고 이야기한다. 

그렇다면 findbyid findbyemail 일차 캐시가 적용되고 안되고 차이는 뭘까
findbyid는 영속성 컨텍스트 내에 캐시가 존재하기 때문에 캐시를 가져오고
findbyemail은 영속성 컨텍스트 내에 캐시가 존재하지 않기 때문에 캐시를 가져오지 않는다.

아이디로 조회하게 되면 영속성 컨텍스트 내에 존재하는 일차 캐시에 엔티티가 있는지 확인해보고 
있으면 db 조회 없이 바로 값을 가져오고 없으면 db 조회를 하게 된다.
실제 쿼리로 db조회를 해서 결과값을 1차 캐시에 한번 저장하고 보여준다. 

아까전에 transactional 어노테이션을 넣어서 테스트를 진행했는데

실제로 프린트는 네번찍혀ㅑㅆ다 
transactional 1차 캐시에 적용이 안됬기 때문이다. 
이렇게 넣으면 
id값을 통해서 1차 캐시가 동작하게 된다.
jpa 조회 성능이 올라가게 된다. 직접 id값을 통해서 조회하느 ㄴ경우는 드문 편이긴 한다. 
그렇지만 jpa 특성상 id값을 조회한 조회가 매우 빈번하게 일어난다. 
업데이트나 딜리트 쿼리를 사용하게 되면 기본적인 id값에 대한 조회가 빈번하게 일어나니깐
1차 캐시를 사용함으로써 

영속성 컨텍스트 내의 캐시를 이해하게 되면 flush의 메소드의 역할도 이해할 수 있게 된다. 






































